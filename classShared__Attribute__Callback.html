<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Shared_Attribute_Callback&lt; MaxAttributes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.16.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classShared__Attribute__Callback-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Shared_Attribute_Callback&lt; MaxAttributes &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Shared attribute update callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Documentation about the specific use of shared attribute update in ThingsBoard can be found here <a href="https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server">https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server</a>.  
 <a href="classShared__Attribute__Callback.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Shared__Attribute__Callback_8h_source.html">Shared_Attribute_Callback.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Shared_Attribute_Callback&lt; MaxAttributes &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classShared__Attribute__Callback__inherit__graph.svg" width="247" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Shared_Attribute_Callback&lt; MaxAttributes &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classShared__Attribute__Callback__coll__graph.svg" width="247" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43dee24b3a779bf7490b8d227fe1a311"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShared__Attribute__Callback.html#a43dee24b3a779bf7490b8d227fe1a311">Shared_Attribute_Callback</a> ()=default</td></tr>
<tr class="memdesc:a43dee24b3a779bf7490b8d227fe1a311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classShared__Attribute__Callback.html#a43dee24b3a779bf7490b8d227fe1a311">More...</a><br /></td></tr>
<tr class="separator:a43dee24b3a779bf7490b8d227fe1a311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d52240b9997525817482bdc84ab243c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9d52240b9997525817482bdc84ab243c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classShared__Attribute__Callback.html#a9d52240b9997525817482bdc84ab243c">Shared_Attribute_Callback</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback, Args const &amp;... args)</td></tr>
<tr class="memdesc:a9d52240b9997525817482bdc84ab243c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs callback, will be called upon shared attribute update arrival, where atleast one of the given multiple shared attributes subscribed was updated by the cloud.  <a href="classShared__Attribute__Callback.html#a9d52240b9997525817482bdc84ab243c">More...</a><br /></td></tr>
<tr class="separator:a9d52240b9997525817482bdc84ab243c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2924f4a5876645a4fbd16283ace483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShared__Attribute__Callback.html#afa2924f4a5876645a4fbd16283ace483">~Shared_Attribute_Callback</a> () override=default</td></tr>
<tr class="separator:afa2924f4a5876645a4fbd16283ace483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad975862363207452838f59fd2487ba80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html">CString_Container</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShared__Attribute__Callback.html#ad975862363207452838f59fd2487ba80">Get_Attributes</a> () const</td></tr>
<tr class="memdesc:ad975862363207452838f59fd2487ba80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the subscribed shared attributes that will result in the callback method being called if any of those attributes values is changed by the cloud.  <a href="classShared__Attribute__Callback.html#ad975862363207452838f59fd2487ba80">More...</a><br /></td></tr>
<tr class="separator:ad975862363207452838f59fd2487ba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f8b19b105b5656178538418f783fcd"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a13f8b19b105b5656178538418f783fcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classShared__Attribute__Callback.html#a13f8b19b105b5656178538418f783fcd">Set_Attributes</a> (Args const &amp;... args)</td></tr>
<tr class="memdesc:a13f8b19b105b5656178538418f783fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the subscribed shared attributes that will result in the callback method being called if any of those attributes values is changed by the cloud.  <a href="classShared__Attribute__Callback.html#a13f8b19b105b5656178538418f783fcd">More...</a><br /></td></tr>
<tr class="separator:a13f8b19b105b5656178538418f783fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCallback.html">Callback&lt; void, JsonObjectConst const &amp; &gt;</a></td></tr>
<tr class="memitem:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#af6b5fc773befdf0c5bc64c05fe81a2e2">Callback</a> ()=default</td></tr>
<tr class="memdesc:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classCallback.html#af6b5fc773befdf0c5bc64c05fe81a2e2">More...</a><br /></td></tr>
<tr class="separator:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a61f5f8a1122ed4e35141fc496a59b601">Callback</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback)</td></tr>
<tr class="memdesc:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classCallback.html#a61f5f8a1122ed4e35141fc496a59b601">More...</a><br /></td></tr>
<tr class="separator:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a52cfeb10d8cca2d116c8ba383575553a">~Callback</a> ()=default</td></tr>
<tr class="memdesc:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual default destructor, created to ensure that if a pointer to this class is used and deleted, we will also call the derived base class destructor.  <a href="classCallback.html#a52cfeb10d8cca2d116c8ba383575553a">More...</a><br /></td></tr>
<tr class="separator:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ae4574c0ae7c6531b5b298d8dcc183557">Call_Callback</a> (argument_types const &amp;... arguments) const</td></tr>
<tr class="memdesc:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the callback that was subscribed, when this class instance was initally created.  <a href="classCallback.html#ae4574c0ae7c6531b5b298d8dcc183557">More...</a><br /></td></tr>
<tr class="separator:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ab665b8ffd158f44daeb05613bd00c5d8">Set_Callback</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback)</td></tr>
<tr class="memdesc:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback method that will be called upon data arrival with the given data that was received. If nullptr is passed the callback will never be called and instead return with a defaulted instance of the requested return variable.  <a href="classCallback.html#ab665b8ffd158f44daeb05613bd00c5d8">More...</a><br /></td></tr>
<tr class="separator:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCallback.html">Callback&lt; void, JsonObjectConst const &amp; &gt;</a></td></tr>
<tr class="memitem:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> = std::function&lt; void(argument_types... arguments)&gt;</td></tr>
<tr class="memdesc:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature.  <a href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">More...</a><br /></td></tr>
<tr class="separator:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT&gt;<br />
class Shared_Attribute_Callback&lt; MaxAttributes &gt;</div><p >Shared attribute update callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Documentation about the specific use of shared attribute update in ThingsBoard can be found here <a href="https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server">https://thingsboard.io/docs/reference/mqtt-api/#subscribe-to-attribute-updates-from-the-server</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MaxAttributes</td><td>Maximum amount of attributes that will ever be requested with this instance of the class, allows to use an array on the stack in the background. Be aware though the size set in this template and the size passed to the ThingsBoard MaxAttributes template need to be the same or the value in this class lower, if not some of the requested keys may be lost, default = DEFAULT_ATTRIBUTES_AMOUNT (1) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43dee24b3a779bf7490b8d227fe1a311" name="a43dee24b3a779bf7490b8d227fe1a311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dee24b3a779bf7490b8d227fe1a311">&#9670;&#160;</a></span>Shared_Attribute_Callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classShared__Attribute__Callback.html">Shared_Attribute_Callback</a>&lt; MaxAttributes &gt;<a class="el" href="classShared__Attribute__Callback.html">::Shared_Attribute_Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr. </p>

</div>
</div>
<a id="a9d52240b9997525817482bdc84ab243c" name="a9d52240b9997525817482bdc84ab243c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d52240b9997525817482bdc84ab243c">&#9670;&#160;</a></span>Shared_Attribute_Callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classShared__Attribute__Callback.html">Shared_Attribute_Callback</a>&lt; MaxAttributes &gt;<a class="el" href="classShared__Attribute__Callback.html">::Shared_Attribute_Callback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs callback, will be called upon shared attribute update arrival, where atleast one of the given multiple shared attributes subscribed was updated by the cloud. </p>
<dl class="section note"><dt>Note</dt><dd>If the update does not include any of the given shared attributes the callback is not called. </dd>
<dd>
Directly forwards the given arguments to the overloaded <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> constructor, meaning all combinatons of arguments that would initalize an std::vector can be used to call this constructor. See possible std::vector constructors here <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>, for the possible passable parameters. The possibilites mainly consist out of the fill constructor, where a number n and a value is given and then the value is copied into that many elements, alternatively if no value is given the default constructed value is copied n times instead, or the range constructor where we can pass an interator to the start and to the end of the data container (last element + 1) to copy every element in between thoose iterators, in the same order as in the original data container. The last option is a copy constructor where we pass another container and all the values of that container will be copied into our buffer </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the container constructor and therefore allow to use every overloaded constructor without having to explicitly implement them </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>callback method that will be called upon data arrival with the given data that was received. If nullptr is passed the callback will never be called and instead return with a defaulted instance of the requested return variable </td></tr>
    <tr><td class="paramname">...args</td><td>Attributes to suscribe, that will be forwarded into the overloaded <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> constructor see <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a> for more information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa2924f4a5876645a4fbd16283ace483" name="afa2924f4a5876645a4fbd16283ace483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2924f4a5876645a4fbd16283ace483">&#9670;&#160;</a></span>~Shared_Attribute_Callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classShared__Attribute__Callback.html">Shared_Attribute_Callback</a>&lt; MaxAttributes &gt;::~<a class="el" href="classShared__Attribute__Callback.html">Shared_Attribute_Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad975862363207452838f59fd2487ba80" name="ad975862363207452838f59fd2487ba80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad975862363207452838f59fd2487ba80">&#9670;&#160;</a></span>Get_Attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html">CString_Container</a> const  &amp; <a class="el" href="classShared__Attribute__Callback.html">Shared_Attribute_Callback</a>&lt; MaxAttributes &gt;::Get_Attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all the subscribed shared attributes that will result in the callback method being called if any of those attributes values is changed by the cloud. </p>
<dl class="section return"><dt>Returns</dt><dd>Subscribed shared attributes </dd></dl>

</div>
</div>
<a id="a13f8b19b105b5656178538418f783fcd" name="a13f8b19b105b5656178538418f783fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f8b19b105b5656178538418f783fcd">&#9670;&#160;</a></span>Set_Attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxAttributes = DEFAULT_ATTRIBUTES_AMOUNT&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classShared__Attribute__Callback.html">Shared_Attribute_Callback</a>&lt; MaxAttributes &gt;::Set_Attributes </td>
          <td>(</td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the subscribed shared attributes that will result in the callback method being called if any of those attributes values is changed by the cloud. </p>
<dl class="section note"><dt>Note</dt><dd>Directly forwards the given arguments to the overloaded <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> constructor, meaning all combinatons of arguments that would initalize an std::vector can be used to call this constructor. See possible std::vector constructors here <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>, for the possible passable parameters. The possibilites mainly consist out of the fill constructor, where a number n and a value is given and then the value is copied into that many elements, alternatively if no value is given the default constructed value is copied n times instead, or the range constructor where we can pass an interator to the start and to the end of the data container (last element + 1) to copy every element in between thoose iterators, in the same order as in the original data container. The last option is a copy constructor where we pass another container and all the values of that container will be copied into our buffer </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> assign method and therefore allow to use every overloaded <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> assign without having to implement them </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>Attributes to subscribe, that will be forwarded into the overloaded <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> assign method see <a href="https://en.cppreference.com/w/cpp/container/vector/assign">https://en.cppreference.com/w/cpp/container/vector/assign</a> for more information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Shared__Attribute__Callback_8h_source.html">Shared_Attribute_Callback.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
