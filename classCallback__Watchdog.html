<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Callback_Watchdog Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.16.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCallback__Watchdog-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Callback_Watchdog Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wrapper class which allows to start a timer and if it is not stopped in the given time then the internally subscribed callback will be called, which informs the user of the failure to stop the timer in time, meaning a timeout has occured.  
 <a href="classCallback__Watchdog.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Callback__Watchdog_8h_source.html">Callback_Watchdog.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Callback_Watchdog:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCallback__Watchdog__inherit__graph.svg" width="162" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Callback_Watchdog:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCallback__Watchdog__coll__graph.svg" width="162" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0bb2b2a9ef783149f21bb634d192670"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#ab0bb2b2a9ef783149f21bb634d192670">Callback_Watchdog</a> ()=default</td></tr>
<tr class="memdesc:ab0bb2b2a9ef783149f21bb634d192670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty timeout timer callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classCallback__Watchdog.html#ab0bb2b2a9ef783149f21bb634d192670">More...</a><br /></td></tr>
<tr class="separator:ab0bb2b2a9ef783149f21bb634d192670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39806b6fe9b2eb23a41225c3f499aac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#ad39806b6fe9b2eb23a41225c3f499aac">Callback_Watchdog</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback)</td></tr>
<tr class="memdesc:ad39806b6fe9b2eb23a41225c3f499aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs callback, will be called if the timeout time passes without <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> being called beforehand.  <a href="classCallback__Watchdog.html#ad39806b6fe9b2eb23a41225c3f499aac">More...</a><br /></td></tr>
<tr class="separator:ad39806b6fe9b2eb23a41225c3f499aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b43283565b9e874b335c318eadc79d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9">once</a> (uint64_t const &amp;timeout_microseconds)</td></tr>
<tr class="memdesc:a7b43283565b9e874b335c318eadc79d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the watchdog timer once for the given timeout.  <a href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9">More...</a><br /></td></tr>
<tr class="separator:a7b43283565b9e874b335c318eadc79d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833d862e5d64fe89cbe30383bf9b5032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032">detach</a> ()</td></tr>
<tr class="memdesc:a833d862e5d64fe89cbe30383bf9b5032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the currently ongoing watchdog timer and ensures the callback is not called. Timer can simply be restarted with calling <a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9" title="Starts the watchdog timer once for the given timeout.">once()</a> again.  <a href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032">More...</a><br /></td></tr>
<tr class="separator:a833d862e5d64fe89cbe30383bf9b5032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d2c61e95e81c1c3a96e111fdf31d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#ab0d2c61e95e81c1c3a96e111fdf31d72">update</a> ()</td></tr>
<tr class="memdesc:ab0d2c61e95e81c1c3a96e111fdf31d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally checks if the time already passed, has to be done because we are using a simple software timer.  <a href="classCallback__Watchdog.html#ab0d2c61e95e81c1c3a96e111fdf31d72">More...</a><br /></td></tr>
<tr class="separator:ab0d2c61e95e81c1c3a96e111fdf31d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCallback.html">Callback&lt; void &gt;</a></td></tr>
<tr class="memitem:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#af6b5fc773befdf0c5bc64c05fe81a2e2">Callback</a> ()=default</td></tr>
<tr class="memdesc:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classCallback.html#af6b5fc773befdf0c5bc64c05fe81a2e2">More...</a><br /></td></tr>
<tr class="separator:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a61f5f8a1122ed4e35141fc496a59b601">Callback</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback)</td></tr>
<tr class="memdesc:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classCallback.html#a61f5f8a1122ed4e35141fc496a59b601">More...</a><br /></td></tr>
<tr class="separator:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a52cfeb10d8cca2d116c8ba383575553a">~Callback</a> ()=default</td></tr>
<tr class="memdesc:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual default destructor, created to ensure that if a pointer to this class is used and deleted, we will also call the derived base class destructor.  <a href="classCallback.html#a52cfeb10d8cca2d116c8ba383575553a">More...</a><br /></td></tr>
<tr class="separator:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ae4574c0ae7c6531b5b298d8dcc183557">Call_Callback</a> (argument_types const &amp;... arguments) const</td></tr>
<tr class="memdesc:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the callback that was subscribed, when this class instance was initally created.  <a href="classCallback.html#ae4574c0ae7c6531b5b298d8dcc183557">More...</a><br /></td></tr>
<tr class="separator:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ab665b8ffd158f44daeb05613bd00c5d8">Set_Callback</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback)</td></tr>
<tr class="memdesc:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback method that will be called upon data arrival with the given data that was received. If nullptr is passed the callback will never be called and instead return with a defaulted instance of the requested return variable.  <a href="classCallback.html#ab665b8ffd158f44daeb05613bd00c5d8">More...</a><br /></td></tr>
<tr class="separator:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCallback.html">Callback&lt; void &gt;</a></td></tr>
<tr class="memitem:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> = std::function&lt; void(argument_types... arguments)&gt;</td></tr>
<tr class="memdesc:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature.  <a href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">More...</a><br /></td></tr>
<tr class="separator:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Wrapper class which allows to start a timer and if it is not stopped in the given time then the internally subscribed callback will be called, which informs the user of the failure to stop the timer in time, meaning a timeout has occured. </p>
<dl class="section note"><dt>Note</dt><dd>The class wraps around either the Arduino timer class from Arduino (<a href="https://github.com/contrem/arduino-timer">https://github.com/contrem/arduino-timer</a>) or the offical ESP Timer implementation from Espressif (<a href="https://github.com/espressif/esp-idf/tree/master/examples/system/esp_timer">https://github.com/espressif/esp-idf/tree/master/examples/system/esp_timer</a>), the latter takes precendence if it exists. This is done because it uses FreeRTOS to start the actual timer in the background, which removes the need for a Hardware Timer with Interrupts as well as the need for active polling, while still achieve the advantage of accurate timings. For all other use cases where the ESP timer does not exists we instead use the Arduino timer as a fallback, because is is a simple software timer with active polling that works on all Arduino based devices. Tt simply uses the millis() method per default but can be configured over template arguments to use other methods that return the current time.</dd></dl>
<p>The class instance is meant to be started with <a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9" title="Starts the watchdog timer once for the given timeout.">once()</a> which will then call the registered callback after the timeout has passed, if the <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> method has not been called yet. This results in behaviour similair to an ESP task watchdog but without as high of an accuracy and without immediately restarting the device when triggered, allowing to let it fail and handle the error case silently by the user in the callback method. Documentation about the specific uses and caviates of the ESP Timer implementation can be found here <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_timer.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_timer.html</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab0bb2b2a9ef783149f21bb634d192670" name="ab0bb2b2a9ef783149f21bb634d192670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bb2b2a9ef783149f21bb634d192670">&#9670;&#160;</a></span>Callback_Watchdog() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callback_Watchdog::Callback_Watchdog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty timeout timer callback, will result in never being called. Internals are simply default constructed as nullptr. </p>

</div>
</div>
<a id="ad39806b6fe9b2eb23a41225c3f499aac" name="ad39806b6fe9b2eb23a41225c3f499aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39806b6fe9b2eb23a41225c3f499aac">&#9670;&#160;</a></span>Callback_Watchdog() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callback_Watchdog::Callback_Watchdog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs callback, will be called if the timeout time passes without <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> being called beforehand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> method that will be called as soon as the internal software timers have processed that the given timeout time passed without <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> being called beforehand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a833d862e5d64fe89cbe30383bf9b5032" name="a833d862e5d64fe89cbe30383bf9b5032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833d862e5d64fe89cbe30383bf9b5032">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Callback_Watchdog::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the currently ongoing watchdog timer and ensures the callback is not called. Timer can simply be restarted with calling <a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9" title="Starts the watchdog timer once for the given timeout.">once()</a> again. </p>

</div>
</div>
<a id="a7b43283565b9e874b335c318eadc79d9" name="a7b43283565b9e874b335c318eadc79d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b43283565b9e874b335c318eadc79d9">&#9670;&#160;</a></span>once()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Callback_Watchdog::once </td>
          <td>(</td>
          <td class="paramtype">uint64_t const &amp;&#160;</td>
          <td class="paramname"><em>timeout_microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the watchdog timer once for the given timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_microseconds</td><td>Amount of microseconds until the <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> method is excpected to have been called or the initally given callback method will be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0d2c61e95e81c1c3a96e111fdf31d72" name="ab0d2c61e95e81c1c3a96e111fdf31d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d2c61e95e81c1c3a96e111fdf31d72">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Callback_Watchdog::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally checks if the time already passed, has to be done because we are using a simple software timer. </p>
<dl class="section note"><dt>Note</dt><dd>Indirectly called from the interal processing loop of this library, so we expect the user to relatively often call the internal library loop() function. In the worst case the actual call of the callback method might be massively delayed compared to the original given timeout time.</dd></dl>
<p>This is the case if the timeout occured but we just updated the internal time before, that timeout will then only be registered on the next update call. Meaning if we call the internal library loop() function every 500 milliseconds it might be delayed by that time in the worst case. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Callback__Watchdog_8h_source.html">Callback_Watchdog.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
