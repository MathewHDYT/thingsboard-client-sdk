<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: OTA_Update_Callback Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.16.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classOTA__Update__Callback-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OTA_Update_Callback Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Over the air firmware update callback wrapper.  
 <a href="classOTA__Update__Callback.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OTA__Update__Callback_8h_source.html">OTA_Update_Callback.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OTA_Update_Callback:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classOTA__Update__Callback__inherit__graph.svg" width="216" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for OTA_Update_Callback:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classOTA__Update__Callback__coll__graph.svg" width="216" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3fa7b00234f950f8f529569456171dae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a3fa7b00234f950f8f529569456171dae">OTA_Update_Callback</a> ()=default</td></tr>
<tr class="memdesc:a3fa7b00234f950f8f529569456171dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callbacks, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classOTA__Update__Callback.html#a3fa7b00234f950f8f529569456171dae">More...</a><br /></td></tr>
<tr class="separator:a3fa7b00234f950f8f529569456171dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833f235f3f3b1732c272c38ad89ed79d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a833f235f3f3b1732c272c38ad89ed79d">OTA_Update_Callback</a> (char const *current_fw_title, char const *current_fw_version, <a class="el" href="classIUpdater.html">IUpdater</a> *updater, <a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> finished_callback, <a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classsize__t.html">size_t</a> const &amp;, <a class="el" href="classsize__t.html">size_t</a> const &amp; &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a> progress_callback=nullptr, <a class="el" href="classCallback.html">Callback</a>&lt; void &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a> update_starting_callback=nullptr, <a class="el" href="classuint8__t.html">uint8_t</a> chunk_retries=<a class="el" href="OTA__Update__Callback_8h.html#a38c3ced5cfe0c4c30998f5173fb131ed">CHUNK_RETRIES</a>, uint16_t chunk_size=<a class="el" href="OTA__Update__Callback_8h.html#aa5627c8879830b626f3cbd7ea043a22f">CHUNK_SIZE</a>, uint64_t const &amp;timeout_microseconds=<a class="el" href="OTA__Update__Callback_8h.html#aa6b7d9ed3b3bb063028c01d14481d5ec">REQUEST_TIMEOUT_MS</a>)</td></tr>
<tr class="memdesc:a833f235f3f3b1732c272c38ad89ed79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs callbacks that will be called to inform about the OTA firmware update process.  <a href="classOTA__Update__Callback.html#a833f235f3f3b1732c272c38ad89ed79d">More...</a><br /></td></tr>
<tr class="separator:a833f235f3f3b1732c272c38ad89ed79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04d685493f1b1699337664f2ca78cad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#ab04d685493f1b1699337664f2ca78cad">~OTA_Update_Callback</a> () override=default</td></tr>
<tr class="separator:ab04d685493f1b1699337664f2ca78cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89711fdf8ea13750f8e7e4de4ca06af"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#af89711fdf8ea13750f8e7e4de4ca06af">Get_Firmware_Title</a> () const</td></tr>
<tr class="memdesc:af89711fdf8ea13750f8e7e4de4ca06af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current firmware title.  <a href="classOTA__Update__Callback.html#af89711fdf8ea13750f8e7e4de4ca06af">More...</a><br /></td></tr>
<tr class="separator:af89711fdf8ea13750f8e7e4de4ca06af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cd99e3198075320dcce1face549dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a28cd99e3198075320dcce1face549dff">Set_Firmware_Title</a> (const char *current_fw_title)</td></tr>
<tr class="memdesc:a28cd99e3198075320dcce1face549dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current firmware title.  <a href="classOTA__Update__Callback.html#a28cd99e3198075320dcce1face549dff">More...</a><br /></td></tr>
<tr class="separator:a28cd99e3198075320dcce1face549dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5ec36b5f1c86619f224bf3b027b2f7"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#acc5ec36b5f1c86619f224bf3b027b2f7">Get_Firmware_Version</a> () const</td></tr>
<tr class="memdesc:acc5ec36b5f1c86619f224bf3b027b2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current firmware version.  <a href="classOTA__Update__Callback.html#acc5ec36b5f1c86619f224bf3b027b2f7">More...</a><br /></td></tr>
<tr class="separator:acc5ec36b5f1c86619f224bf3b027b2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f29e7b9e5ab7a80d167d17468facab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a12f29e7b9e5ab7a80d167d17468facab">Set_Firmware_Version</a> (const char *current_fw_version)</td></tr>
<tr class="memdesc:a12f29e7b9e5ab7a80d167d17468facab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current firmware version.  <a href="classOTA__Update__Callback.html#a12f29e7b9e5ab7a80d167d17468facab">More...</a><br /></td></tr>
<tr class="separator:a12f29e7b9e5ab7a80d167d17468facab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641a07bad07a09e1159c69b927de1d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIUpdater.html">IUpdater</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a641a07bad07a09e1159c69b927de1d31">Get_Updater</a> () const</td></tr>
<tr class="memdesc:a641a07bad07a09e1159c69b927de1d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware.  <a href="classOTA__Update__Callback.html#a641a07bad07a09e1159c69b927de1d31">More...</a><br /></td></tr>
<tr class="separator:a641a07bad07a09e1159c69b927de1d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6f6c5dba7c3587c1e255f85e8dd67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a68f6f6c5dba7c3587c1e255f85e8dd67">Set_Updater</a> (<a class="el" href="classIUpdater.html">IUpdater</a> *updater)</td></tr>
<tr class="memdesc:a68f6f6c5dba7c3587c1e255f85e8dd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware.  <a href="classOTA__Update__Callback.html#a68f6f6c5dba7c3587c1e255f85e8dd67">More...</a><br /></td></tr>
<tr class="separator:a68f6f6c5dba7c3587c1e255f85e8dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed96feb4704aa1797f58691a38b60e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#aaed96feb4704aa1797f58691a38b60e4">Get_Request_ID</a> () const</td></tr>
<tr class="memdesc:aaed96feb4704aa1797f58691a38b60e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unique request identifier that is connected to the original request.  <a href="classOTA__Update__Callback.html#aaed96feb4704aa1797f58691a38b60e4">More...</a><br /></td></tr>
<tr class="separator:aaed96feb4704aa1797f58691a38b60e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232af9829271e400d9dc87a1db414c15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a232af9829271e400d9dc87a1db414c15">Set_Request_ID</a> (<a class="el" href="classsize__t.html">size_t</a> const &amp;request_id)</td></tr>
<tr class="memdesc:a232af9829271e400d9dc87a1db414c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the unique request identifier that is connected to the original request.  <a href="classOTA__Update__Callback.html#a232af9829271e400d9dc87a1db414c15">More...</a><br /></td></tr>
<tr class="separator:a232af9829271e400d9dc87a1db414c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a9a10cf7b8d7f564efe37144e30de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a18a9a10cf7b8d7f564efe37144e30de7">Call_Progress_Callback</a> (<a class="el" href="classsize__t.html">size_t</a> const &amp;current, <a class="el" href="classsize__t.html">size_t</a> const &amp;total) const</td></tr>
<tr class="memdesc:a18a9a10cf7b8d7f564efe37144e30de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the progress callback that was subscribed, when this class instance was initally created.  <a href="classOTA__Update__Callback.html#a18a9a10cf7b8d7f564efe37144e30de7">More...</a><br /></td></tr>
<tr class="separator:a18a9a10cf7b8d7f564efe37144e30de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90cf176e2b73b3511159e5436d10d33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#ad90cf176e2b73b3511159e5436d10d33">Set_Progress_Callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classsize__t.html">size_t</a> const &amp;, <a class="el" href="classsize__t.html">size_t</a> const &amp; &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a> progress_callback)</td></tr>
<tr class="memdesc:ad90cf176e2b73b3511159e5436d10d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the progress callback method.  <a href="classOTA__Update__Callback.html#ad90cf176e2b73b3511159e5436d10d33">More...</a><br /></td></tr>
<tr class="separator:ad90cf176e2b73b3511159e5436d10d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a4b43de7cae9ef0888ce320127f66e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#ad7a4b43de7cae9ef0888ce320127f66e">Call_Update_Starting_Callback</a> () const</td></tr>
<tr class="memdesc:ad7a4b43de7cae9ef0888ce320127f66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the update starting callback that was subscribed, when this class instance was initally created.  <a href="classOTA__Update__Callback.html#ad7a4b43de7cae9ef0888ce320127f66e">More...</a><br /></td></tr>
<tr class="separator:ad7a4b43de7cae9ef0888ce320127f66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982b6ec13b778dff9f193b8b96496ff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a982b6ec13b778dff9f193b8b96496ff5">Set_Update_Starting_Callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a> update_starting_callback)</td></tr>
<tr class="memdesc:a982b6ec13b778dff9f193b8b96496ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the update starting callback method.  <a href="classOTA__Update__Callback.html#a982b6ec13b778dff9f193b8b96496ff5">More...</a><br /></td></tr>
<tr class="separator:a982b6ec13b778dff9f193b8b96496ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bba6976d2b5892a261731cf414a242e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint8__t.html">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a1bba6976d2b5892a261731cf414a242e">Get_Chunk_Retries</a> () const</td></tr>
<tr class="memdesc:a1bba6976d2b5892a261731cf414a242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of times we attempt to download each chunk of the OTA firmware binary file.  <a href="classOTA__Update__Callback.html#a1bba6976d2b5892a261731cf414a242e">More...</a><br /></td></tr>
<tr class="separator:a1bba6976d2b5892a261731cf414a242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af894dea03167177f6d312bf157e3b88a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#af894dea03167177f6d312bf157e3b88a">Set_Chunk_Retries</a> (<a class="el" href="classuint8__t.html">uint8_t</a> chunk_retries)</td></tr>
<tr class="memdesc:af894dea03167177f6d312bf157e3b88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of times we attempt to download each chunk of the OTA firmware binary file.  <a href="classOTA__Update__Callback.html#af894dea03167177f6d312bf157e3b88a">More...</a><br /></td></tr>
<tr class="separator:af894dea03167177f6d312bf157e3b88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296f37cba143d7f207fcae3c8d34de7e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a296f37cba143d7f207fcae3c8d34de7e">Get_Chunk_Size</a> () const</td></tr>
<tr class="memdesc:a296f37cba143d7f207fcae3c8d34de7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the chunks that the firmware binary data will be split into.  <a href="classOTA__Update__Callback.html#a296f37cba143d7f207fcae3c8d34de7e">More...</a><br /></td></tr>
<tr class="separator:a296f37cba143d7f207fcae3c8d34de7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4768106542e64dff3c17b814e0aa3c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a4768106542e64dff3c17b814e0aa3c72">Set_Chunk_Size</a> (uint16_t chunk_size)</td></tr>
<tr class="memdesc:a4768106542e64dff3c17b814e0aa3c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the chunks that the firmware binary data will be split into.  <a href="classOTA__Update__Callback.html#a4768106542e64dff3c17b814e0aa3c72">More...</a><br /></td></tr>
<tr class="separator:a4768106542e64dff3c17b814e0aa3c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf433764cd8381f50ca2e395cd61438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimeoutable__Request.html">Timeoutable_Request</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a0cf433764cd8381f50ca2e395cd61438">Get_Request_Timeout</a> ()</td></tr>
<tr class="memdesc:a0cf433764cd8381f50ca2e395cd61438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the request timeout callback.  <a href="classOTA__Update__Callback.html#a0cf433764cd8381f50ca2e395cd61438">More...</a><br /></td></tr>
<tr class="separator:a0cf433764cd8381f50ca2e395cd61438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCallback.html">Callback&lt; void, bool const &amp; &gt;</a></td></tr>
<tr class="memitem:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#af6b5fc773befdf0c5bc64c05fe81a2e2">Callback</a> ()=default</td></tr>
<tr class="memdesc:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classCallback.html#af6b5fc773befdf0c5bc64c05fe81a2e2">More...</a><br /></td></tr>
<tr class="separator:af6b5fc773befdf0c5bc64c05fe81a2e2 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a61f5f8a1122ed4e35141fc496a59b601">Callback</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback)</td></tr>
<tr class="memdesc:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classCallback.html#a61f5f8a1122ed4e35141fc496a59b601">More...</a><br /></td></tr>
<tr class="separator:a61f5f8a1122ed4e35141fc496a59b601 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a52cfeb10d8cca2d116c8ba383575553a">~Callback</a> ()=default</td></tr>
<tr class="memdesc:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual default destructor, created to ensure that if a pointer to this class is used and deleted, we will also call the derived base class destructor.  <a href="classCallback.html#a52cfeb10d8cca2d116c8ba383575553a">More...</a><br /></td></tr>
<tr class="separator:a52cfeb10d8cca2d116c8ba383575553a inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ae4574c0ae7c6531b5b298d8dcc183557">Call_Callback</a> (argument_types const &amp;... arguments) const</td></tr>
<tr class="memdesc:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the callback that was subscribed, when this class instance was initally created.  <a href="classCallback.html#ae4574c0ae7c6531b5b298d8dcc183557">More...</a><br /></td></tr>
<tr class="separator:ae4574c0ae7c6531b5b298d8dcc183557 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ab665b8ffd158f44daeb05613bd00c5d8">Set_Callback</a> (<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> callback)</td></tr>
<tr class="memdesc:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback method that will be called upon data arrival with the given data that was received. If nullptr is passed the callback will never be called and instead return with a defaulted instance of the requested return variable.  <a href="classCallback.html#ab665b8ffd158f44daeb05613bd00c5d8">More...</a><br /></td></tr>
<tr class="separator:ab665b8ffd158f44daeb05613bd00c5d8 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCallback.html">Callback&lt; void, bool const &amp; &gt;</a></td></tr>
<tr class="memitem:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a> = std::function&lt; void(argument_types... arguments)&gt;</td></tr>
<tr class="memdesc:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature.  <a href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">More...</a><br /></td></tr>
<tr class="separator:a9cb9c819e739fdf44e1a5cdaaf818bc3 inherit pub_types_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Over the air firmware update callback wrapper. </p>
<dl class="section note"><dt>Note</dt><dd>Contains the needed configuration settings to create the request that should be sent to the server. Documentation about the specific use of Over the air updates in ThingsBoard can be found here <a href="https://thingsboard.io/docs/user-guide/ota-updates/">https://thingsboard.io/docs/user-guide/ota-updates/</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3fa7b00234f950f8f529569456171dae" name="a3fa7b00234f950f8f529569456171dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa7b00234f950f8f529569456171dae">&#9670;&#160;</a></span>OTA_Update_Callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OTA_Update_Callback::OTA_Update_Callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty callbacks, will result in never being called. Internals are simply default constructed as nullptr. </p>

</div>
</div>
<a id="a833f235f3f3b1732c272c38ad89ed79d" name="a833f235f3f3b1732c272c38ad89ed79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833f235f3f3b1732c272c38ad89ed79d">&#9670;&#160;</a></span>OTA_Update_Callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OTA_Update_Callback::OTA_Update_Callback </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>current_fw_title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>current_fw_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIUpdater.html">IUpdater</a> *&#160;</td>
          <td class="paramname"><em>updater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">function</a>&#160;</td>
          <td class="paramname"><em>finished_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classsize__t.html">size_t</a> const &amp;, <a class="el" href="classsize__t.html">size_t</a> const &amp; &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a>&#160;</td>
          <td class="paramname"><em>progress_callback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a>&#160;</td>
          <td class="paramname"><em>update_starting_callback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint8__t.html">uint8_t</a>&#160;</td>
          <td class="paramname"><em>chunk_retries</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#a38c3ced5cfe0c4c30998f5173fb131ed">CHUNK_RETRIES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#aa5627c8879830b626f3cbd7ea043a22f">CHUNK_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t const &amp;&#160;</td>
          <td class="paramname"><em>timeout_microseconds</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#aa6b7d9ed3b3bb063028c01d14481d5ec">REQUEST_TIMEOUT_MS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs callbacks that will be called to inform about the OTA firmware update process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_fw_title</td><td>Non owning pointer to the firmware title the device has choosen, is used to only allow updates with the same given title, other updates will be canceled. Additionally it has to be kept alive by the user for the runtime of the OTA Update process </td></tr>
    <tr><td class="paramname">current_fw_version</td><td>Non owning pointer to the firmware version the device is currently on, is used to only allow updates with a different version, other updates will be canceled. Additionally it has to be kept alive by the user for the runtime of the OTA Update process </td></tr>
    <tr><td class="paramname">updater</td><td>Non owning pointer to the updater implementation that writes the given firmware data. Additionally it has to be kept alive by the user for the runtime of the OTA Update process </td></tr>
    <tr><td class="paramname">finished_callback</td><td>End callback method that will be called as soon as the OTA firmware update, either finished successfully or failed. Is meant to allow to either restart the device if the udpate was successfull or to restart any stopped services before the update started in the subscribed update_starting_callback </td></tr>
    <tr><td class="paramname">progress_callback</td><td>Progress callback method that will be called every time our current progress of downloading the complete firmware data changed, meaning it will be called if the amount of already downloaded chunks increased. Is meant to allow to display a progress bar or print the current progress of the update into the console with the currently already downloaded amount of chunks and the total amount of chunks, default = nullptr </td></tr>
    <tr><td class="paramname">update_starting_callback</td><td>Update starting callback method that will be called as soon as the shared attribute firmware keys have been received and processed and the moment before we subscribe the necessary topics for the OTA firmware update. Is meant to give a moment were any additional processes or communication with the cloud can be stopped to ensure the update process runs as smooth as possible. To ensure that calling the <a class="el" href="classThingsBoardSized.html#afe4397300dbe8bd707a6ac384340ae28" title="Clears all currently subscribed callbacks and unsubscribed from all currently subscribed MQTT topics.">ThingsBoardSized::Cleanup_Subscriptions()</a> method can be used which stops any receiving of data over MQTT besides the one for the OTA firmware update, if this method is used ensure to call all subscribe methods again so they can be resubscribed, in the method passed to the finished_callback if the update failed and we do not restart the device, default = nullptr </td></tr>
    <tr><td class="paramname">chunk_retries</td><td>Amount of retries the OTA firmware update has to download each seperate chunk with a given size, before the complete download is stopped and registered as failed, default = CHUNK_RETRIES </td></tr>
    <tr><td class="paramname">chunk_size</td><td>Size of the chunks that the firmware binary data will be split into, increased chunk size might speed up the process by a little bit, but requires more heap memory, </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum amount of time in microseconds for the OTA firmware update for each seperate chunk, until that chunk counts as a timeout, retries is then subtraced by one and the download is retried, default = REQUEST_TIMEOUT_MS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab04d685493f1b1699337664f2ca78cad" name="ab04d685493f1b1699337664f2ca78cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04d685493f1b1699337664f2ca78cad">&#9670;&#160;</a></span>~OTA_Update_Callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OTA_Update_Callback::~OTA_Update_Callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a18a9a10cf7b8d7f564efe37144e30de7" name="a18a9a10cf7b8d7f564efe37144e30de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a9a10cf7b8d7f564efe37144e30de7">&#9670;&#160;</a></span>Call_Progress_Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Call_Progress_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the progress callback that was subscribed, when this class instance was initally created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>Already received and processsed amount of chunks </td></tr>
    <tr><td class="paramname">total</td><td>Total amount of chunks we need to receive and process until the update has completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7a4b43de7cae9ef0888ce320127f66e" name="ad7a4b43de7cae9ef0888ce320127f66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a4b43de7cae9ef0888ce320127f66e">&#9670;&#160;</a></span>Call_Update_Starting_Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Call_Update_Starting_Callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the update starting callback that was subscribed, when this class instance was initally created. </p>

</div>
</div>
<a id="a1bba6976d2b5892a261731cf414a242e" name="a1bba6976d2b5892a261731cf414a242e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bba6976d2b5892a261731cf414a242e">&#9670;&#160;</a></span>Get_Chunk_Retries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint8__t.html">uint8_t</a> OTA_Update_Callback::Get_Chunk_Retries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the amount of times we attempt to download each chunk of the OTA firmware binary file. </p>
<dl class="section note"><dt>Note</dt><dd>If the download fails because it times out, the write of the chunk data with the updater implementation fails then the retries are decreased by 1 until we hit 0, if that is the case then we instead stop the OTA firmware update completely </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of retries for each single chunk before we abort the update </dd></dl>

</div>
</div>
<a id="a296f37cba143d7f207fcae3c8d34de7e" name="a296f37cba143d7f207fcae3c8d34de7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296f37cba143d7f207fcae3c8d34de7e">&#9670;&#160;</a></span>Get_Chunk_Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t OTA_Update_Callback::Get_Chunk_Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the chunks that the firmware binary data will be split into. </p>
<dl class="section note"><dt>Note</dt><dd>Increased chunk size might speed up the process, but requires more heap memory, because the whole chunk is saved into the heap before it can be processed and is then overwriten after it has been used by the next chunk. This means the size passed to this method or with the constructor needs to be small enough to be allocated on the heap at runtime </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Size of each single chunk to be downloaded </dd></dl>

</div>
</div>
<a id="af89711fdf8ea13750f8e7e4de4ca06af" name="af89711fdf8ea13750f8e7e4de4ca06af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89711fdf8ea13750f8e7e4de4ca06af">&#9670;&#160;</a></span>Get_Firmware_Title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const  * OTA_Update_Callback::Get_Firmware_Title </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current firmware title. </p>
<dl class="section note"><dt>Note</dt><dd>Used to decide if an OTA firmware update is already installed and therefore should not be downloaded, this is only done if the title of the update and the current firmware title are the same because if they are not then this firmware is meant for another device type </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non owning pointer to the current firmware title of the device. Owned by the user that passed it originally in the constructor or with the <a class="el" href="classOTA__Update__Callback.html#a28cd99e3198075320dcce1face549dff">Set_Firmware_Title</a> method </dd></dl>

</div>
</div>
<a id="acc5ec36b5f1c86619f224bf3b027b2f7" name="acc5ec36b5f1c86619f224bf3b027b2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5ec36b5f1c86619f224bf3b027b2f7">&#9670;&#160;</a></span>Get_Firmware_Version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const  * OTA_Update_Callback::Get_Firmware_Version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current firmware version. </p>
<dl class="section note"><dt>Note</dt><dd>Used to decide if an OTA firmware update is already installed and therefore should not be downloaded, this is only done if the version of the update and the current firmware version are different, because if they are not then we would download the same firmware as is already on the device </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non owning pointer to the current firmware version of the device. Owned by the user that passed it originally in the constructor or with the <a class="el" href="classOTA__Update__Callback.html#a12f29e7b9e5ab7a80d167d17468facab">Set_Firmware_Version</a> method </dd></dl>

</div>
</div>
<a id="aaed96feb4704aa1797f58691a38b60e4" name="aaed96feb4704aa1797f58691a38b60e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed96feb4704aa1797f58691a38b60e4">&#9670;&#160;</a></span>Get_Request_ID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsize__t.html">size_t</a> const  &amp; OTA_Update_Callback::Get_Request_ID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the unique request identifier that is connected to the original request. </p>
<dl class="section note"><dt>Note</dt><dd>Will be later used to verifiy which <a class="el" href="classOTA__Update__Callback.html">OTA_Update_Callback</a> is connected to which received OTA firmware update </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Unique identifier connected to the request to start the OTA firmware update </dd></dl>

</div>
</div>
<a id="a0cf433764cd8381f50ca2e395cd61438" name="a0cf433764cd8381f50ca2e395cd61438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf433764cd8381f50ca2e395cd61438">&#9670;&#160;</a></span>Get_Request_Timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimeoutable__Request.html">Timeoutable_Request</a> &amp; OTA_Update_Callback::Get_Request_Timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the request timeout callback. </p>
<dl class="section note"><dt>Note</dt><dd>Will be called when no response to the request was received in the expected amount of time, causing the internal watchdog to time out. To achieve this behaviour the internal timer can be started and stopped, and simply calls the subscribed callback if the timer is not stopped before it times out </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Request timeout callback </dd></dl>

</div>
</div>
<a id="a641a07bad07a09e1159c69b927de1d31" name="a641a07bad07a09e1159c69b927de1d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641a07bad07a09e1159c69b927de1d31">&#9670;&#160;</a></span>Get_Updater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIUpdater.html">IUpdater</a> * OTA_Update_Callback::Get_Updater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware. </p>
<dl class="section return"><dt>Returns</dt><dd>Non owning pointer to the updater implementation that writes the given firmware data. Owned by the user that passed it originally in the constructor or with the <a class="el" href="classOTA__Update__Callback.html#a68f6f6c5dba7c3587c1e255f85e8dd67">Set_Updater</a> method </dd></dl>

</div>
</div>
<a id="af894dea03167177f6d312bf157e3b88a" name="af894dea03167177f6d312bf157e3b88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af894dea03167177f6d312bf157e3b88a">&#9670;&#160;</a></span>Set_Chunk_Retries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Chunk_Retries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint8__t.html">uint8_t</a>&#160;</td>
          <td class="paramname"><em>chunk_retries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the amount of times we attempt to download each chunk of the OTA firmware binary file. </p>
<dl class="section note"><dt>Note</dt><dd>If the download fails because it times out, the write of the chunk data with the updater implementation fails then the retries are decreased by 1 until we hit 0, if that is the case then we instead stop the OTA firmware update completely </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk_retries</td><td>Amount of retries for each single chunk before we abort the update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4768106542e64dff3c17b814e0aa3c72" name="a4768106542e64dff3c17b814e0aa3c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4768106542e64dff3c17b814e0aa3c72">&#9670;&#160;</a></span>Set_Chunk_Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Chunk_Size </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>chunk_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the chunks that the firmware binary data will be split into. </p>
<dl class="section note"><dt>Note</dt><dd>Increased chunk size might speed up the process, but requires more heap memory, because the whole chunk is saved into the heap before it can be processed and is then overwriten after it has been used by the next chunk This means the size passed to this method or with the constructor needs to be small enough to be allocated on the heap at runtime </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk_size</td><td>Size of each single chunk to be downloaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28cd99e3198075320dcce1face549dff" name="a28cd99e3198075320dcce1face549dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cd99e3198075320dcce1face549dff">&#9670;&#160;</a></span>Set_Firmware_Title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Firmware_Title </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>current_fw_title</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current firmware title. </p>
<dl class="section note"><dt>Note</dt><dd>Used to decide if an OTA firmware update is already installed and therefore should not be downloaded, this is only done if the title of the update and the current firmware title are the same because if they are not then this firmware is meant for another device type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_fw_title</td><td>Non owning pointer to the current firmware title of the device. Additionally it has to be kept alive by the user for the runtime of the OTA Update process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12f29e7b9e5ab7a80d167d17468facab" name="a12f29e7b9e5ab7a80d167d17468facab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f29e7b9e5ab7a80d167d17468facab">&#9670;&#160;</a></span>Set_Firmware_Version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Firmware_Version </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>current_fw_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current firmware version. </p>
<dl class="section note"><dt>Note</dt><dd>Used to decide if an OTA firmware update is already installed and therefore should not be downloaded, this is only done if the version of the update and the current firmware version are different, because if they are not then we would download the same firmware as is already on the device </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_fw_version</td><td>Non owning pointer to the current firmware version of the device. Additionally it has to be kept alive by the user for the runtime of the OTA Update process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad90cf176e2b73b3511159e5436d10d33" name="ad90cf176e2b73b3511159e5436d10d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90cf176e2b73b3511159e5436d10d33">&#9670;&#160;</a></span>Set_Progress_Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Progress_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classsize__t.html">size_t</a> const &amp;, <a class="el" href="classsize__t.html">size_t</a> const &amp; &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a>&#160;</td>
          <td class="paramname"><em>progress_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the progress callback method. </p>
<dl class="section note"><dt>Note</dt><dd>Is meant to allow to display a progress bar or print the current progress of the update. With the currently already downloaded and processed amount of chunks and the total amount of chunks to process </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progress_callback</td><td>Progress callback method that will be called every time our current progress of downloading and processing the complete firmware data changed, meaning it will be called if the amount of already downloaded chunks increased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a232af9829271e400d9dc87a1db414c15" name="a232af9829271e400d9dc87a1db414c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232af9829271e400d9dc87a1db414c15">&#9670;&#160;</a></span>Set_Request_ID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Request_ID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>request_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the unique request identifier that is connected to the original request. </p>
<dl class="section note"><dt>Note</dt><dd>Will be later used to verifiy which <a class="el" href="classOTA__Update__Callback.html">OTA_Update_Callback</a> is connected to which received OTA firmware update. Not meant for external use, because the value is overwritten by internal method calls anyway once the class instance has been passed as a parameter anyway. This is the case because only the internal methods knows the current request id that this callback will be attached too </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request_id</td><td>Unique identifier connected to the request to start the OTA firmware update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982b6ec13b778dff9f193b8b96496ff5" name="a982b6ec13b778dff9f193b8b96496ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982b6ec13b778dff9f193b8b96496ff5">&#9670;&#160;</a></span>Set_Update_Starting_Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Update_Starting_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void &gt;<a class="el" href="classCallback.html#a9cb9c819e739fdf44e1a5cdaaf818bc3">::function</a>&#160;</td>
          <td class="paramname"><em>update_starting_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the update starting callback method. </p>
<dl class="section note"><dt>Note</dt><dd>Is meant to give a moment were any additional processes or communication with the cloud can be stopped to ensure the update process runs as smooth as possible. To ensure that calling the <a class="el" href="classThingsBoardSized.html#afe4397300dbe8bd707a6ac384340ae28" title="Clears all currently subscribed callbacks and unsubscribed from all currently subscribed MQTT topics.">ThingsBoardSized::Cleanup_Subscriptions()</a> method can be used which stops any receiving of data over MQTT besides the one for the OTA firmware update, if this method is used ensure to call all subscribe methods again so they can be resubscribed, in the method passed to the finished_callback if the update failed and we do not restart the device </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_starting_callback</td><td>Update starting callback method that will be called as soon as the shared attribute firmware keys have been received and processed and the moment before we subscribe the necessary topics for the OTA firmware update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68f6f6c5dba7c3587c1e255f85e8dd67" name="a68f6f6c5dba7c3587c1e255f85e8dd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f6f6c5dba7c3587c1e255f85e8dd67">&#9670;&#160;</a></span>Set_Updater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Updater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIUpdater.html">IUpdater</a> *&#160;</td>
          <td class="paramname"><em>updater</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updater</td><td>Updater implementation that writes the given firmware data. Additionally it has to be kept alive by the user for the runtime of the OTA Update process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="OTA__Update__Callback_8h_source.html">OTA_Update_Callback.h</a></li>
<li>src/<a class="el" href="OTA__Update__Callback_8cpp.html">OTA_Update_Callback.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
