<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: IMQTT_Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.16.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classIMQTT__Client-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IMQTT_Client Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>MQTT Client interface that contains the method that a class that can be used to send and receive data over an MQTT connection should implement.  
 <a href="classIMQTT__Client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IMQTT__Client_8h_source.html">IMQTT_Client.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a099185cb8b1d45b796c57b4e4bfbefb5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a099185cb8b1d45b796c57b4e4bfbefb5">~IMQTT_Client</a> ()</td></tr>
<tr class="memdesc:a099185cb8b1d45b796c57b4e4bfbefb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual default destructor, created to ensure that if a pointer to this class is used and deleted, we will also call the derived base class destructor.   <a href="classIMQTT__Client.html#a099185cb8b1d45b796c57b4e4bfbefb5">More...</a><br /></td></tr>
<tr class="separator:a099185cb8b1d45b796c57b4e4bfbefb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4494b3cee25b1fed5ed6049aa9016bec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec">set_data_callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void, char *, <a class="el" href="classuint8__t.html">uint8_t</a> *, unsigned int &gt;::function callback)=0</td></tr>
<tr class="memdesc:a4494b3cee25b1fed5ed6049aa9016bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, if any message is received by the MQTT broker.  <a href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec">More...</a><br /></td></tr>
<tr class="separator:a4494b3cee25b1fed5ed6049aa9016bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07f448cb4962ff6ddfed17aa743ffb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#ad07f448cb4962ff6ddfed17aa743ffb9">set_connect_callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void &gt;::function callback)=0</td></tr>
<tr class="memdesc:ad07f448cb4962ff6ddfed17aa743ffb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, if we have successfully established a connection with the MQTT broker.  <a href="classIMQTT__Client.html#ad07f448cb4962ff6ddfed17aa743ffb9">More...</a><br /></td></tr>
<tr class="separator:ad07f448cb4962ff6ddfed17aa743ffb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f54876f0f75c30bcb589621318b0add"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a6f54876f0f75c30bcb589621318b0add">set_buffer_size</a> (uint16_t receive_buffer_size, uint16_t send_buffer_size)=0</td></tr>
<tr class="memdesc:a6f54876f0f75c30bcb589621318b0add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the buffer for sent and received MQTT messages.  <a href="classIMQTT__Client.html#a6f54876f0f75c30bcb589621318b0add">More...</a><br /></td></tr>
<tr class="separator:a6f54876f0f75c30bcb589621318b0add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9273edc7b3559e3fcde199ee13add1"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a3f9273edc7b3559e3fcde199ee13add1">get_receive_buffer_size</a> ()=0</td></tr>
<tr class="memdesc:a3f9273edc7b3559e3fcde199ee13add1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previously set size of the internal buffer size meant for incoming MQTT data.  <a href="classIMQTT__Client.html#a3f9273edc7b3559e3fcde199ee13add1">More...</a><br /></td></tr>
<tr class="separator:a3f9273edc7b3559e3fcde199ee13add1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ac6bd2e2d61f9efda039a1e9a4838"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9a7ac6bd2e2d61f9efda039a1e9a4838">get_send_buffer_size</a> ()=0</td></tr>
<tr class="memdesc:a9a7ac6bd2e2d61f9efda039a1e9a4838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previously set size of the internal buffer size meant for outgoing MQTT data.  <a href="classIMQTT__Client.html#a9a7ac6bd2e2d61f9efda039a1e9a4838">More...</a><br /></td></tr>
<tr class="separator:a9a7ac6bd2e2d61f9efda039a1e9a4838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9098518b44d6991842b8b73f05e37913"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9098518b44d6991842b8b73f05e37913">set_server</a> (char const *domain, uint16_t port)=0</td></tr>
<tr class="memdesc:a9098518b44d6991842b8b73f05e37913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the server and port that the client should connect with over MQTT.  <a href="classIMQTT__Client.html#a9098518b44d6991842b8b73f05e37913">More...</a><br /></td></tr>
<tr class="separator:a9098518b44d6991842b8b73f05e37913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de7ff0f7d65326e6b638591c36e7395"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a1de7ff0f7d65326e6b638591c36e7395">connect</a> (char const *client_id, char const *user_name, char const *password)=0</td></tr>
<tr class="memdesc:a1de7ff0f7d65326e6b638591c36e7395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to the previously with set_server configured server instance and port with the given credentials.  <a href="classIMQTT__Client.html#a1de7ff0f7d65326e6b638591c36e7395">More...</a><br /></td></tr>
<tr class="separator:a1de7ff0f7d65326e6b638591c36e7395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb78386592aa959e1ba68131c7cf93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a05cb78386592aa959e1ba68131c7cf93">disconnect</a> ()=0</td></tr>
<tr class="memdesc:a05cb78386592aa959e1ba68131c7cf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force disconnects from the previously connected server and should release all used resources.  <a href="classIMQTT__Client.html#a05cb78386592aa959e1ba68131c7cf93">More...</a><br /></td></tr>
<tr class="separator:a05cb78386592aa959e1ba68131c7cf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bf1e088f569976adfd524e029f9d23"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a14bf1e088f569976adfd524e029f9d23">loop</a> ()=0</td></tr>
<tr class="memdesc:a14bf1e088f569976adfd524e029f9d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives / sends any outstanding messages from and to the MQTT broker.  <a href="classIMQTT__Client.html#a14bf1e088f569976adfd524e029f9d23">More...</a><br /></td></tr>
<tr class="separator:a14bf1e088f569976adfd524e029f9d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98289274313ffb902bcce37c11c500b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a98289274313ffb902bcce37c11c500b8">publish</a> (char const *topic, <a class="el" href="classuint8__t.html">uint8_t</a> const *payload, <a class="el" href="classsize__t.html">size_t</a> const &amp;length)=0</td></tr>
<tr class="memdesc:a98289274313ffb902bcce37c11c500b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given payload over the previously established connection.  <a href="classIMQTT__Client.html#a98289274313ffb902bcce37c11c500b8">More...</a><br /></td></tr>
<tr class="separator:a98289274313ffb902bcce37c11c500b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4833fb14319650281e060c239a7f19"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#acf4833fb14319650281e060c239a7f19">subscribe</a> (char const *topic)=0</td></tr>
<tr class="memdesc:acf4833fb14319650281e060c239a7f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes to MQTT message on the given topic, which will cause an internal callback to be called for each message received on that topic from the server, it should then, call the previously configured callback with <a class="el" href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec" title="Sets the callback that is called, if any message is received by the MQTT broker.">set_data_callback()</a> with the received data.  <a href="classIMQTT__Client.html#acf4833fb14319650281e060c239a7f19">More...</a><br /></td></tr>
<tr class="separator:acf4833fb14319650281e060c239a7f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53e8dcc18899b63532f47da2bbace3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a5a53e8dcc18899b63532f47da2bbace3">unsubscribe</a> (char const *topic)=0</td></tr>
<tr class="memdesc:a5a53e8dcc18899b63532f47da2bbace3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribes to previously subscribed MQTT messages of the given topic.  <a href="classIMQTT__Client.html#a5a53e8dcc18899b63532f47da2bbace3">More...</a><br /></td></tr>
<tr class="separator:a5a53e8dcc18899b63532f47da2bbace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfe357c2b35a844c9643d328af29ada"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9dfe357c2b35a844c9643d328af29ada">connected</a> ()=0</td></tr>
<tr class="memdesc:a9dfe357c2b35a844c9643d328af29ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet.  <a href="classIMQTT__Client.html#a9dfe357c2b35a844c9643d328af29ada">More...</a><br /></td></tr>
<tr class="separator:a9dfe357c2b35a844c9643d328af29ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88007244e42383ab98ea688146fe82ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a88007244e42383ab98ea688146fe82ef">get_connection_state</a> () const =0</td></tr>
<tr class="memdesc:a88007244e42383ab98ea688146fe82ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current connection state to the server includes possible intermediate states between connecting and disconnecting.  <a href="classIMQTT__Client.html#a88007244e42383ab98ea688146fe82ef">More...</a><br /></td></tr>
<tr class="separator:a88007244e42383ab98ea688146fe82ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ab9821780cc94173d964274a0d93b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a33ab9821780cc94173d964274a0d93b6">get_last_connection_error</a> () const =0</td></tr>
<tr class="memdesc:a33ab9821780cc94173d964274a0d93b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to deciper the reason for a failure, while attempting to establish a connection to the MQTT broker.  <a href="classIMQTT__Client.html#a33ab9821780cc94173d964274a0d93b6">More...</a><br /></td></tr>
<tr class="separator:a33ab9821780cc94173d964274a0d93b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f87b4a1d18d1d91e1c32b49185c824"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a20f87b4a1d18d1d91e1c32b49185c824">subscribe_connection_state_changed_callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a>, <a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a> &gt;::function callback)=0</td></tr>
<tr class="memdesc:a20f87b4a1d18d1d91e1c32b49185c824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, whenever the underlying state of our connection with the MQTT broker changes.  <a href="classIMQTT__Client.html#a20f87b4a1d18d1d91e1c32b49185c824">More...</a><br /></td></tr>
<tr class="separator:a20f87b4a1d18d1d91e1c32b49185c824"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >MQTT Client interface that contains the method that a class that can be used to send and receive data over an MQTT connection should implement. </p>
<dl class="section note"><dt>Note</dt><dd>Seperates the specific implementation used from the ThingsBoard client, allows to use different clients depending on different needs. In this case the main use case of the seperation is to both support Espressif IDF and Arduino with the following libraries as recommendations. The default MQTT Client for Arduino is the PubSubClient forked from ThingsBoard (<a href="https://github.com/thingsboard/pubsubclient">https://github.com/thingsboard/pubsubclient</a>), it includes fixes to solve issues with using std::function callbacks for non ESP boards. For Espressif IDF however the default MQTT Client is the esp-mqtt (<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html</a>) component. The aforementioned recommendations are already implemented in the library and can can simply be used and included when using the library, for Arduino the Arduino_MQTT_Client can simply be included and for Espressif IDF the Espressif_MQTT_Client can simply be included, the implementations have been tested and should be compatible when used in conjunction with the ThingsBoard client. Alternatively when using Arduino it is possible to enable support for THINGSBOARD_ENABLE_STREAM_UTILS by importing the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) in the project. This feature allows to improve the underlying data streams by directly writing the data into the MQTT Client instead of into an output buffer, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint, which only exists on Arduino This then allows to send arbitrary size payloads if that is done the internal buffer of the MQTT Client implementation can theoretically set the value as big as the buffering_size passed to the constructor + enough memory to hold the topic and MQTT Header ~= 20 bytes. This will mean though that all messages are sent over the StreamUtils library as long as they are bigger than the internal send buffer size, which needs more time than sending a message directly but has the advantage of requiring less memory </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a099185cb8b1d45b796c57b4e4bfbefb5" name="a099185cb8b1d45b796c57b4e4bfbefb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099185cb8b1d45b796c57b4e4bfbefb5">&#9670;&#160;</a></span>~IMQTT_Client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IMQTT_Client::~IMQTT_Client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual default destructor, created to ensure that if a pointer to this class is used and deleted, we will also call the derived base class destructor.  </p>
<dl class="section note"><dt>Note</dt><dd>Deleting a base class destructor that does not have a virtual destructor is undefined behaviour, because the derived class destructor originally instantiated with new is never called. This can cause potential memory leaks, because derived classes can not clean up their internal members as expected and instead simply leak them   </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1de7ff0f7d65326e6b638591c36e7395" name="a1de7ff0f7d65326e6b638591c36e7395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de7ff0f7d65326e6b638591c36e7395">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::connect </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects to the previously with set_server configured server instance and port with the given credentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>Non owning pointer to client identification code, that allows to differentiate which MQTT device is sending the traffic to the MQTT broker. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection </td></tr>
    <tr><td class="paramname">user_name</td><td>Non owning pointer to client username that is used to authenticate, who is connecting over MQTT. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection </td></tr>
    <tr><td class="paramname">password</td><td>Non owning pointer to client password that is used to authenticate, who is connecting over MQTT. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the client could establish the connection successfully or not </dd></dl>

</div>
</div>
<a id="a9dfe357c2b35a844c9643d328af29ada" name="a9dfe357c2b35a844c9643d328af29ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfe357c2b35a844c9643d328af29ada">&#9670;&#160;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the client is currently connected or not </dd></dl>

</div>
</div>
<a id="a05cb78386592aa959e1ba68131c7cf93" name="a05cb78386592aa959e1ba68131c7cf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cb78386592aa959e1ba68131c7cf93">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force disconnects from the previously connected server and should release all used resources. </p>
<dl class="section note"><dt>Note</dt><dd>Be aware that Espressif_MQTT_Client automatically reconnects, as long as Espressif_MQTT_Client::set_disable_auto_reconnect was not set to true </dd></dl>

</div>
</div>
<a id="a88007244e42383ab98ea688146fe82ef" name="a88007244e42383ab98ea688146fe82ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88007244e42383ab98ea688146fe82ef">&#9670;&#160;</a></span>get_connection_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a> IMQTT_Client::get_connection_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current connection state to the server includes possible intermediate states between connecting and disconnecting. </p>
<dl class="section note"><dt>Note</dt><dd>Only the Espressif_MQTT_Client ever returns the intermediate states, because the implementation is non blocking. Meaning calling disconnect will not immediately disconnect from the cloud but instead require a while. In comparsion Arduino_MQTT_Client is blocking, meaning we block until we disconnected or connected. If the ERROR state is returned, the reason for the failed connection can be deciphered more clearly using <a class="el" href="classIMQTT__Client.html#a33ab9821780cc94173d964274a0d93b6">get_last_connection_error</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The current state of the connection to the MQTT broker </dd></dl>

</div>
</div>
<a id="a33ab9821780cc94173d964274a0d93b6" name="a33ab9821780cc94173d964274a0d93b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ab9821780cc94173d964274a0d93b6">&#9670;&#160;</a></span>get_last_connection_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a> IMQTT_Client::get_last_connection_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to deciper the reason for a failure, while attempting to establish a connection to the MQTT broker. </p>
<dl class="section note"><dt>Note</dt><dd>Shows the reason for the last failure to connect or the current one, if <a class="el" href="classIMQTT__Client.html#a88007244e42383ab98ea688146fe82ef">get_connection_state</a> returns the ERROR state </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last error that occured while attempting to establish a connection to MQTT </dd></dl>

</div>
</div>
<a id="a3f9273edc7b3559e3fcde199ee13add1" name="a3f9273edc7b3559e3fcde199ee13add1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9273edc7b3559e3fcde199ee13add1">&#9670;&#160;</a></span>get_receive_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint16_t IMQTT_Client::get_receive_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previously set size of the internal buffer size meant for incoming MQTT data. </p>
<dl class="section return"><dt>Returns</dt><dd>Internal size of the buffer </dd></dl>

</div>
</div>
<a id="a9a7ac6bd2e2d61f9efda039a1e9a4838" name="a9a7ac6bd2e2d61f9efda039a1e9a4838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7ac6bd2e2d61f9efda039a1e9a4838">&#9670;&#160;</a></span>get_send_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint16_t IMQTT_Client::get_send_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previously set size of the internal buffer size meant for outgoing MQTT data. </p>
<dl class="section return"><dt>Returns</dt><dd>Internal size of the buffer </dd></dl>

</div>
</div>
<a id="a14bf1e088f569976adfd524e029f9d23" name="a14bf1e088f569976adfd524e029f9d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bf1e088f569976adfd524e029f9d23">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives / sends any outstanding messages from and to the MQTT broker. </p>
<dl class="section note"><dt>Note</dt><dd>Only required if the MQTT client is blocking and does not use a seperate task to process messages. This is the case for Arduino_MQTT_Client, which requires calls to this method to actually process the received and sent data. For the Espressif_MQTT_Client however, this method simply does nothing and never needs to be called, because received and set data is processed using a seperate FreeRTOS task </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether sending or receiving the oustanding the messages was successful or not. Returns false if an internal error occured or the connection has been lost. Exact state can be read from <a class="el" href="classIMQTT__Client.html#a88007244e42383ab98ea688146fe82ef">get_connection_state</a> and <a class="el" href="classIMQTT__Client.html#a33ab9821780cc94173d964274a0d93b6">get_last_connection_error</a> </dd></dl>

</div>
</div>
<a id="a98289274313ffb902bcce37c11c500b8" name="a98289274313ffb902bcce37c11c500b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98289274313ffb902bcce37c11c500b8">&#9670;&#160;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::publish </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint8__t.html">uint8_t</a> const *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the given payload over the previously established connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Non owning pointer to topic that the message is sent over, where different MQTT topics expect a different kind of payload. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the given payload </td></tr>
    <tr><td class="paramname">payload</td><td>Payload containg the data that should be sent </td></tr>
    <tr><td class="paramname">length</td><td>Length of the payload in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether publishing the payload on the given topic was successful or not </dd></dl>

</div>
</div>
<a id="a6f54876f0f75c30bcb589621318b0add" name="a6f54876f0f75c30bcb589621318b0add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f54876f0f75c30bcb589621318b0add">&#9670;&#160;</a></span>set_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::set_buffer_size </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>receive_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>send_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of the buffer for sent and received MQTT messages. </p>
<dl class="section note"><dt>Note</dt><dd>The value can not be bigger than uint16_t because the maximum message size received or sent by MQTT can never be bigger than 64K, because it relies on TCP and the TCP size limit also uses a uint16_t internally for the size parameter </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receive_buffer_size</td><td>Maximum amount of data that can be received via MQTT at once, expected behaviour is that, if bigger packets are received they are discarded and a warning is printed to the console. Should be big enough to hold the biggest response that is expected to be ever received by the device at once </td></tr>
    <tr><td class="paramname">send_buffer_size</td><td>Maximum amount of data that can be sent via MQTT at once, expected behaviour is that, if we attempt to send data that is bigger, it will simply not be sent and a message is printed to the console instead. Should be big enough to hold the biggest request that is expected to be ever sent by the device at once. Alternatively when using Arduino it is possible to enable support for THINGSBOARD_ENABLE_STREAM_UTILS by importing the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) in the project. This feature allows to improve the underlying data streams by directly writing the data into the MQTT Client instead of into an output buffer, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint, which only exists on Arduino This then allows to send arbitrary size payloads if that is done the internal buffer of the MQTT Client implementation can theoretically set the value as big as the buffering_size passed to the constructor + enough memory to hold the topic and MQTT Header ~= 20 bytes. This will mean though that all messages are sent over the StreamUtils library as long as they are bigger than the internal send buffer size, which needs more time than sending a message directly but has the advantage of requiring less memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether allocating the needed memory for the given buffer sizes was successful or not </dd></dl>

</div>
</div>
<a id="ad07f448cb4962ff6ddfed17aa743ffb9" name="ad07f448cb4962ff6ddfed17aa743ffb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07f448cb4962ff6ddfed17aa743ffb9">&#9670;&#160;</a></span>set_connect_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_connect_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void &gt;::function&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, if we have successfully established a connection with the MQTT broker. </p>
<dl class="section note"><dt>Note</dt><dd>Directly set by the used ThingsBoard client to its internal method, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing. If receiving information once the device has connected is wanted by the user it is recommended to use <a class="el" href="classIMQTT__Client.html#a20f87b4a1d18d1d91e1c32b49185c824">subscribe_connection_state_changed_callback</a> method instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on established MQTT connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4494b3cee25b1fed5ed6049aa9016bec" name="a4494b3cee25b1fed5ed6049aa9016bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4494b3cee25b1fed5ed6049aa9016bec">&#9670;&#160;</a></span>set_data_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_data_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void, char *, <a class="el" href="classuint8__t.html">uint8_t</a> *, unsigned int &gt;::function&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, if any message is received by the MQTT broker. </p>
<dl class="section note"><dt>Note</dt><dd>The callback is called with the topic string that the message was received over, as well as the payload data and the size of that payload data. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on received MQTT response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9098518b44d6991842b8b73f05e37913" name="a9098518b44d6991842b8b73f05e37913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9098518b44d6991842b8b73f05e37913">&#9670;&#160;</a></span>set_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_server </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the server and port that the client should connect with over MQTT. </p>
<dl class="section note"><dt>Note</dt><dd>Should be called atleast once before calling <a class="el" href="classIMQTT__Client.html#a1de7ff0f7d65326e6b638591c36e7395" title="Connects to the previously with set_server configured server instance and port with the given credent...">connect()</a> so the target server and port to connect too have been configured </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Non owning pointer to server instance name the client should connect too. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection </td></tr>
    <tr><td class="paramname">port</td><td>Port that will be used to establish a connection and send / receive data. Should be either 1883 for unencrypted MQTT or 8883 for MQTT with TLS/SSL encryption. The latter is recommended if relevant data is sent or if the client receives and handles Remote Procedure Calls or Shared Attribute Update Callbacks from the server, because using an unencrpyted connection, will allow 3rd parties to listen to the communication and impersonate the server sending payloads which might influence the device in unexpected ways. However if Over the Air udpates are enabled secure communication should definetly be enabled, because if that is not done a 3rd party might impersonate the server sending a malicious payload, which is then flashed onto the device instead of the real firmware. Which depeding on the payload might even be able to destroy the device or make it otherwise unusable. See <a href="https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/">https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/</a> for more information on the aforementioned security risk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf4833fb14319650281e060c239a7f19" name="acf4833fb14319650281e060c239a7f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4833fb14319650281e060c239a7f19">&#9670;&#160;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::subscribe </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribes to MQTT message on the given topic, which will cause an internal callback to be called for each message received on that topic from the server, it should then, call the previously configured callback with <a class="el" href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec" title="Sets the callback that is called, if any message is received by the MQTT broker.">set_data_callback()</a> with the received data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Non owning pointer to topic we want to receive a notification about if messages are sent by the server. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to subscribe to the given topic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wheter subscribing the given topic was possible or not, should return false and a warning should be printed, if the connection has been lost or the topic does not exist </dd></dl>

</div>
</div>
<a id="a20f87b4a1d18d1d91e1c32b49185c824" name="a20f87b4a1d18d1d91e1c32b49185c824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f87b4a1d18d1d91e1c32b49185c824">&#9670;&#160;</a></span>subscribe_connection_state_changed_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::subscribe_connection_state_changed_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a>, <a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a> &gt;::function&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, whenever the underlying state of our connection with the MQTT broker changes. </p>
<dl class="section note"><dt>Note</dt><dd>Is called when we for example attempt to connect to the MQTT broker, or once the underlying client has connected or failed to connect. Passes the current connection state, also accessible with <a class="el" href="classIMQTT__Client.html#a88007244e42383ab98ea688146fe82ef">get_connection_state</a> and the last error that occured while trying to connect, also accessible with <a class="el" href="classIMQTT__Client.html#a33ab9821780cc94173d964274a0d93b6">get_last_connection_error</a> as additional information </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on state changes to our MQTT connection <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a53e8dcc18899b63532f47da2bbace3" name="a5a53e8dcc18899b63532f47da2bbace3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a53e8dcc18899b63532f47da2bbace3">&#9670;&#160;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribes to previously subscribed MQTT messages of the given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Non owning pointer to topic we want to stop receiving a notification about if messages are sent by the server Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to unsubscribe from the given topic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wheter unsubscribing the given topic was possible or not, should return false and a warning should be printed, if the connection has been lost or the topic was not previously subscribed </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="IMQTT__Client_8h_source.html">IMQTT_Client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
