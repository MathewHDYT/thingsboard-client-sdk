<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Container&lt; T, Capacity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.16.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classContainer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Container&lt; T, Capacity &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Custom std::array or std::vector implementation that contains a partial vector-like interface implementation. Internal implementation is changed at compile-time to either use the heap if THINGSBOARD_ENABLE_DYNAMIC is set or the stack otherwise.  
 <a href="classContainer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Container_8h_source.html">Container.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Container&lt; T, Capacity &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classContainer__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1555f0ad63721247735d46b55d554619"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a1555f0ad63721247735d46b55d554619">value_type</a> = T</td></tr>
<tr class="separator:a1555f0ad63721247735d46b55d554619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc84beaceafb25895a751f278feb3370"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> = <a class="el" href="classsize__t.html">size_t</a></td></tr>
<tr class="separator:acc84beaceafb25895a751f278feb3370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97344a48f63bbe89812b43d4b5b8c705"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a> = T &amp;</td></tr>
<tr class="separator:a97344a48f63bbe89812b43d4b5b8c705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9972975421e7883e72dc98e170895e35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a> = T const &amp;</td></tr>
<tr class="separator:a9972975421e7883e72dc98e170895e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af691eeff34b7910edcb72fcb13c0e37a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#af691eeff34b7910edcb72fcb13c0e37a">pointer</a> = T *</td></tr>
<tr class="separator:af691eeff34b7910edcb72fcb13c0e37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84aab56b702de9a642ec78b459b7c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#afc84aab56b702de9a642ec78b459b7c8">const_pointer</a> = T const *</td></tr>
<tr class="separator:afc84aab56b702de9a642ec78b459b7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab91ce398967722dc934b52dd75bbdea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#aab91ce398967722dc934b52dd75bbdea">iterator</a> = <a class="el" href="classContainer.html#af691eeff34b7910edcb72fcb13c0e37a">pointer</a></td></tr>
<tr class="separator:aab91ce398967722dc934b52dd75bbdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8a5d2c4c05b7f42db6904d699eb34c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a> = <a class="el" href="classContainer.html#afc84aab56b702de9a642ec78b459b7c8">const_pointer</a></td></tr>
<tr class="separator:a7f8a5d2c4c05b7f42db6904d699eb34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f7aab635bc58d0cb2b1511ce9e5e00b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a3f7aab635bc58d0cb2b1511ce9e5e00b">Container</a> ()</td></tr>
<tr class="memdesc:a3f7aab635bc58d0cb2b1511ce9e5e00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, simply initalizes the underlying c-style array with the necessary capacity. That capacity always has to be bigger than 0, because initalizing a 0 length c-style array can cause certain compilers to produce errors.  <a href="classContainer.html#a3f7aab635bc58d0cb2b1511ce9e5e00b">More...</a><br /></td></tr>
<tr class="separator:a3f7aab635bc58d0cb2b1511ce9e5e00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcfa34f248b64620c9c9b308f13b3fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#aefcfa34f248b64620c9c9b308f13b3fb">Container</a> (<a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> count, <a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a> value=T{})</td></tr>
<tr class="memdesc:aefcfa34f248b64620c9c9b308f13b3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the constructor with the given amount of elements, either x copies of the passed value or x default constructed instances of the underlying type used. Simply forwards the arguments to the insert method, meaning if the initally allocated Capacity is not big enough to hold all elements, then this method will assert and stop the application.  <a href="classContainer.html#aefcfa34f248b64620c9c9b308f13b3fb">More...</a><br /></td></tr>
<tr class="separator:aefcfa34f248b64620c9c9b308f13b3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd848a09eeb13ab4f2acdeff0f60a4a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:aecd848a09eeb13ab4f2acdeff0f60a4a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classContainer.html#aecd848a09eeb13ab4f2acdeff0f60a4a">Container</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:aecd848a09eeb13ab4f2acdeff0f60a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all elements from the given start to exclusively the given end iterator into the underlying data container. Simply forwards the arguments to the insert method, meaning if the initally allocated Capacity is not big enough to hold all elements, then this method will assert and stop the application.  <a href="classContainer.html#aecd848a09eeb13ab4f2acdeff0f60a4a">More...</a><br /></td></tr>
<tr class="separator:aecd848a09eeb13ab4f2acdeff0f60a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ce42aaff388649ccad8315c3437027"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Container &gt; </td></tr>
<tr class="memitem:a37ce42aaff388649ccad8315c3437027"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classContainer.html#a37ce42aaff388649ccad8315c3437027">Container</a> (Iterable_Container const &amp;container)</td></tr>
<tr class="memdesc:a37ce42aaff388649ccad8315c3437027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the begin and end iterator of the given data container and forwards the call to the iterator based constructor.  <a href="classContainer.html#a37ce42aaff388649ccad8315c3437027">More...</a><br /></td></tr>
<tr class="separator:a37ce42aaff388649ccad8315c3437027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab289861d88170c61978e2a91be7e8e48"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab289861d88170c61978e2a91be7e8e48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classContainer.html#ab289861d88170c61978e2a91be7e8e48">assign</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:ab289861d88170c61978e2a91be7e8e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all elements from the given start to exclusively the given end iterator into the underlying data container. Simply forwards the arguments to the insert method, meaning if the initally allocated Capacity is not big enough to hold all elements, then this method will assert and stop the application.   <a href="classContainer.html#ab289861d88170c61978e2a91be7e8e48">More...</a><br /></td></tr>
<tr class="separator:ab289861d88170c61978e2a91be7e8e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c58292cece2339a29060f89d745b35"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classContainer.html">Container</a> &gt; </td></tr>
<tr class="memitem:af9c58292cece2339a29060f89d745b35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classContainer.html#af9c58292cece2339a29060f89d745b35">assign</a> (<a class="el" href="classContainer.html">Container</a> const &amp;container)</td></tr>
<tr class="separator:af9c58292cece2339a29060f89d745b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8befe721dabf1892cd30a3d1c539a8c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a8befe721dabf1892cd30a3d1c539a8c1">empty</a> () const</td></tr>
<tr class="memdesc:a8befe721dabf1892cd30a3d1c539a8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are any elements in the underlying data container.  <a href="classContainer.html#a8befe721dabf1892cd30a3d1c539a8c1">More...</a><br /></td></tr>
<tr class="separator:a8befe721dabf1892cd30a3d1c539a8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2032a9a1e12c804da4137cfc0d44b988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a2032a9a1e12c804da4137cfc0d44b988">size</a> () const</td></tr>
<tr class="memdesc:a2032a9a1e12c804da4137cfc0d44b988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current amount of elements in the underlying data container.  <a href="classContainer.html#a2032a9a1e12c804da4137cfc0d44b988">More...</a><br /></td></tr>
<tr class="separator:a2032a9a1e12c804da4137cfc0d44b988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc44dcdb6b2a7c2e3bf5e68aae26bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a4bc44dcdb6b2a7c2e3bf5e68aae26bef">capacity</a> () const</td></tr>
<tr class="memdesc:a4bc44dcdb6b2a7c2e3bf5e68aae26bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum amount of elements that can be stored in the underlying data container.  <a href="classContainer.html#a4bc44dcdb6b2a7c2e3bf5e68aae26bef">More...</a><br /></td></tr>
<tr class="separator:a4bc44dcdb6b2a7c2e3bf5e68aae26bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c27fa69e488c3efd6cc23e0df0b89e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#aab91ce398967722dc934b52dd75bbdea">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a30c27fa69e488c3efd6cc23e0df0b89e">begin</a> ()</td></tr>
<tr class="memdesc:a30c27fa69e488c3efd6cc23e0df0b89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the underlying data container. If the array is empty, the returned iterator will be equal to <a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a" title="Returns a iterator to one-past-the-last element of the underlying data container.">end()</a>  <a href="classContainer.html#a30c27fa69e488c3efd6cc23e0df0b89e">More...</a><br /></td></tr>
<tr class="separator:a30c27fa69e488c3efd6cc23e0df0b89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c9f9c774651788c2071207a3728647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a84c9f9c774651788c2071207a3728647">begin</a> () const</td></tr>
<tr class="memdesc:a84c9f9c774651788c2071207a3728647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the underlying data container. If the array is empty, the returned iterator will be equal to <a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a" title="Returns a iterator to one-past-the-last element of the underlying data container.">end()</a>   <a href="classContainer.html#a84c9f9c774651788c2071207a3728647">More...</a><br /></td></tr>
<tr class="separator:a84c9f9c774651788c2071207a3728647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48596c6b1d1e0cd8d40bc9a8945726d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a48596c6b1d1e0cd8d40bc9a8945726d2">cbegin</a> () const</td></tr>
<tr class="memdesc:a48596c6b1d1e0cd8d40bc9a8945726d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the underlying data container. If the array is empty, the returned iterator will be equal to <a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a" title="Returns a iterator to one-past-the-last element of the underlying data container.">end()</a>   <a href="classContainer.html#a48596c6b1d1e0cd8d40bc9a8945726d2">More...</a><br /></td></tr>
<tr class="separator:a48596c6b1d1e0cd8d40bc9a8945726d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ac1a8dbeee080de605f1ccd8dc9d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a32ac1a8dbeee080de605f1ccd8dc9d16">front</a> ()</td></tr>
<tr class="memdesc:a32ac1a8dbeee080de605f1ccd8dc9d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return.  <a href="classContainer.html#a32ac1a8dbeee080de605f1ccd8dc9d16">More...</a><br /></td></tr>
<tr class="separator:a32ac1a8dbeee080de605f1ccd8dc9d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc9f6a5119af7ba2051c04ca5b06707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#abcc9f6a5119af7ba2051c04ca5b06707">front</a> () const</td></tr>
<tr class="memdesc:abcc9f6a5119af7ba2051c04ca5b06707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return.   <a href="classContainer.html#abcc9f6a5119af7ba2051c04ca5b06707">More...</a><br /></td></tr>
<tr class="separator:abcc9f6a5119af7ba2051c04ca5b06707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26efbb1e96c96265bffd4e51399f4687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a26efbb1e96c96265bffd4e51399f4687">back</a> ()</td></tr>
<tr class="memdesc:a26efbb1e96c96265bffd4e51399f4687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return.  <a href="classContainer.html#a26efbb1e96c96265bffd4e51399f4687">More...</a><br /></td></tr>
<tr class="separator:a26efbb1e96c96265bffd4e51399f4687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86f230ade93a3eb9db1ba8baa355253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#ac86f230ade93a3eb9db1ba8baa355253">back</a> () const</td></tr>
<tr class="memdesc:ac86f230ade93a3eb9db1ba8baa355253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return.   <a href="classContainer.html#ac86f230ade93a3eb9db1ba8baa355253">More...</a><br /></td></tr>
<tr class="separator:ac86f230ade93a3eb9db1ba8baa355253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4721c10206d7d9762ce393ae6bcf3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#aab91ce398967722dc934b52dd75bbdea">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a">end</a> ()</td></tr>
<tr class="memdesc:abc4721c10206d7d9762ce393ae6bcf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a iterator to one-past-the-last element of the underlying data container.  <a href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a">More...</a><br /></td></tr>
<tr class="separator:abc4721c10206d7d9762ce393ae6bcf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea94941f62f3dceffb980c2f747fcbeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#aea94941f62f3dceffb980c2f747fcbeb">end</a> () const</td></tr>
<tr class="memdesc:aea94941f62f3dceffb980c2f747fcbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a iterator to one-past-the-last element of the underlying data container.   <a href="classContainer.html#aea94941f62f3dceffb980c2f747fcbeb">More...</a><br /></td></tr>
<tr class="separator:aea94941f62f3dceffb980c2f747fcbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9041ff5ab8770ed91e7af4769a666604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a9041ff5ab8770ed91e7af4769a666604">cend</a> () const</td></tr>
<tr class="memdesc:a9041ff5ab8770ed91e7af4769a666604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a iterator to one-past-the-last element of the underlying data container.   <a href="classContainer.html#a9041ff5ab8770ed91e7af4769a666604">More...</a><br /></td></tr>
<tr class="separator:a9041ff5ab8770ed91e7af4769a666604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e686e24111437e2c0e013ca3e5c9856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a4e686e24111437e2c0e013ca3e5c9856">push_back</a> (<a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a> element)</td></tr>
<tr class="memdesc:a4e686e24111437e2c0e013ca3e5c9856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element at the end of the underlying data container.  <a href="classContainer.html#a4e686e24111437e2c0e013ca3e5c9856">More...</a><br /></td></tr>
<tr class="separator:a4e686e24111437e2c0e013ca3e5c9856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420e3d5aa4d0c0e4b74a2b0b8ac07b0e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a420e3d5aa4d0c0e4b74a2b0b8ac07b0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classContainer.html#a420e3d5aa4d0c0e4b74a2b0b8ac07b0e">insert</a> (<a class="el" href="classContainer.html#aab91ce398967722dc934b52dd75bbdea">iterator</a> position, InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:a420e3d5aa4d0c0e4b74a2b0b8ac07b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all elements from the given start to exclusively the given end iterator into the underlying data container. The copying is started from the position before the given iterator (position - 1)  <a href="classContainer.html#a420e3d5aa4d0c0e4b74a2b0b8ac07b0e">More...</a><br /></td></tr>
<tr class="separator:a420e3d5aa4d0c0e4b74a2b0b8ac07b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2c92a9e10fcbb1b978ac943bbc38a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a3e2c92a9e10fcbb1b978ac943bbc38a3">erase</a> (<a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a> position)</td></tr>
<tr class="memdesc:a3e2c92a9e10fcbb1b978ac943bbc38a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at the given position, has to move all element one to the left if the iterator does not point to the last valid element in the underlying data container.  <a href="classContainer.html#a3e2c92a9e10fcbb1b978ac943bbc38a3">More...</a><br /></td></tr>
<tr class="separator:a3e2c92a9e10fcbb1b978ac943bbc38a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370bf8739915fe6ec8849d3a95380a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a370bf8739915fe6ec8849d3a95380a96">at</a> (<a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> const &amp;index)</td></tr>
<tr class="memdesc:a370bf8739915fe6ec8849d3a95380a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index, with bounds checking.  <a href="classContainer.html#a370bf8739915fe6ec8849d3a95380a96">More...</a><br /></td></tr>
<tr class="separator:a370bf8739915fe6ec8849d3a95380a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa8ef8e94069a3a64d7753ab3de66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a69fa8ef8e94069a3a64d7753ab3de66d">at</a> (<a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> const &amp;index) const</td></tr>
<tr class="memdesc:a69fa8ef8e94069a3a64d7753ab3de66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index, with bounds checking.   <a href="classContainer.html#a69fa8ef8e94069a3a64d7753ab3de66d">More...</a><br /></td></tr>
<tr class="separator:a69fa8ef8e94069a3a64d7753ab3de66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b0a941bcf514063a35c7905f923e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#a97b0a941bcf514063a35c7905f923e06">operator[]</a> (<a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> index)</td></tr>
<tr class="memdesc:a97b0a941bcf514063a35c7905f923e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="classContainer.html#a97b0a941bcf514063a35c7905f923e06">More...</a><br /></td></tr>
<tr class="separator:a97b0a941bcf514063a35c7905f923e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc1204725965a5d9f55717b39f797d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#addc1204725965a5d9f55717b39f797d0">operator[]</a> (<a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> index) const</td></tr>
<tr class="memdesc:addc1204725965a5d9f55717b39f797d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.   <a href="classContainer.html#addc1204725965a5d9f55717b39f797d0">More...</a><br /></td></tr>
<tr class="separator:addc1204725965a5d9f55717b39f797d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bcd6ef4952381b900b980d1847c51c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainer.html#aa5bcd6ef4952381b900b980d1847c51c">clear</a> ()</td></tr>
<tr class="memdesc:aa5bcd6ef4952381b900b980d1847c51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="classContainer.html#a2032a9a1e12c804da4137cfc0d44b988" title="Gets the current amount of elements in the underlying data container.">size()</a> returns zero.  <a href="classContainer.html#aa5bcd6ef4952381b900b980d1847c51c">More...</a><br /></td></tr>
<tr class="separator:aa5bcd6ef4952381b900b980d1847c51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, <a class="el" href="classsize__t.html">size_t</a> Capacity&gt;<br />
class Container&lt; T, Capacity &gt;</div><p >Custom std::array or std::vector implementation that contains a partial vector-like interface implementation. Internal implementation is changed at compile-time to either use the heap if THINGSBOARD_ENABLE_DYNAMIC is set or the stack otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>Allows to use the exact same method calls independent on if the custom <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> implementation or std::vector is used. Support for the vector-like interface is achieved through a simple index that keeps count of the elements that have been instantiated with actual values by the push or insert method. Iterator based support is achieved through returning a pointer, which can be automatically used the same as an iterator implementation tagged as std::random_iterator_tag. This allows to use the most efficient implementation of standard algorithms, while keeping the actual internal implementation as simple as possible.</dd></dl>
<p>The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a container may be passed to any function that expects a pointer to an element of a c-array </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the underlying data container. Must be both CopyAssignable (have a copy assignment operator, for the push_back operation) as well as be Default-Constructible (have a default constructor, for the construction of the intial state of the underlying data container) </td></tr>
    <tr><td class="paramname">Capacity</td><td>Amount of elements that can ever be saved into the underlying data container, allows to wrap a simple c-array and allocate it on the stack. Attempting to allocate more elements is not possible, because the size is fixed at compile-time </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7f8a5d2c4c05b7f42db6904d699eb34c" name="a7f8a5d2c4c05b7f42db6904d699eb34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8a5d2c4c05b7f42db6904d699eb34c">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::const_iterator =  <a class="el" href="classContainer.html#afc84aab56b702de9a642ec78b459b7c8">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc84aab56b702de9a642ec78b459b7c8" name="afc84aab56b702de9a642ec78b459b7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc84aab56b702de9a642ec78b459b7c8">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::const_pointer =  T const *</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9972975421e7883e72dc98e170895e35" name="a9972975421e7883e72dc98e170895e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9972975421e7883e72dc98e170895e35">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::const_reference =  T const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab91ce398967722dc934b52dd75bbdea" name="aab91ce398967722dc934b52dd75bbdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab91ce398967722dc934b52dd75bbdea">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::iterator =  <a class="el" href="classContainer.html#af691eeff34b7910edcb72fcb13c0e37a">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af691eeff34b7910edcb72fcb13c0e37a" name="af691eeff34b7910edcb72fcb13c0e37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af691eeff34b7910edcb72fcb13c0e37a">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::pointer =  T *</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97344a48f63bbe89812b43d4b5b8c705" name="a97344a48f63bbe89812b43d4b5b8c705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97344a48f63bbe89812b43d4b5b8c705">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::reference =  T &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc84beaceafb25895a751f278feb3370" name="acc84beaceafb25895a751f278feb3370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc84beaceafb25895a751f278feb3370">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::size_type =  <a class="el" href="classsize__t.html">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1555f0ad63721247735d46b55d554619" name="a1555f0ad63721247735d46b55d554619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1555f0ad63721247735d46b55d554619">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f7aab635bc58d0cb2b1511ce9e5e00b" name="a3f7aab635bc58d0cb2b1511ce9e5e00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7aab635bc58d0cb2b1511ce9e5e00b">&#9670;&#160;</a></span>Container() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;<a class="el" href="classContainer.html">::Container</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, simply initalizes the underlying c-style array with the necessary capacity. That capacity always has to be bigger than 0, because initalizing a 0 length c-style array can cause certain compilers to produce errors. </p>

</div>
</div>
<a id="aefcfa34f248b64620c9c9b308f13b3fb" name="aefcfa34f248b64620c9c9b308f13b3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcfa34f248b64620c9c9b308f13b3fb">&#9670;&#160;</a></span>Container() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;<a class="el" href="classContainer.html">::Container</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em> = <code>T{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the constructor with the given amount of elements, either x copies of the passed value or x default constructed instances of the underlying type used. Simply forwards the arguments to the insert method, meaning if the initally allocated Capacity is not big enough to hold all elements, then this method will assert and stop the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Amount of elements that we want to create and copy the value into </td></tr>
    <tr><td class="paramname">value</td><td>Value that should be copied into the created elements, default = T{} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecd848a09eeb13ab4f2acdeff0f60a4a" name="aecd848a09eeb13ab4f2acdeff0f60a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd848a09eeb13ab4f2acdeff0f60a4a">&#9670;&#160;</a></span>Container() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;<a class="el" href="classContainer.html">::Container</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all elements from the given start to exclusively the given end iterator into the underlying data container. Simply forwards the arguments to the insert method, meaning if the initally allocated Capacity is not big enough to hold all elements, then this method will assert and stop the application. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that allows for forward incrementable access to data of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to one past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37ce42aaff388649ccad8315c3437027" name="a37ce42aaff388649ccad8315c3437027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ce42aaff388649ccad8315c3437027">&#9670;&#160;</a></span>Container() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename Iterable_Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;<a class="el" href="classContainer.html">::Container</a> </td>
          <td>(</td>
          <td class="paramtype">Iterable_Container&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the begin and end iterator of the given data container and forwards the call to the iterator based constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterable_Container</td><td>Class that contains the actual data we want to copy into our internal data container, requires access to a <a class="el" href="classContainer.html#a48596c6b1d1e0cd8d40bc9a8945726d2" title="Returns an iterator to the first element of the underlying data container. If the array is empty,...">cbegin()</a> and <a class="el" href="classContainer.html#a9041ff5ab8770ed91e7af4769a666604" title="Returns a iterator to one-past-the-last element of the underlying data container.">cend()</a> method, that point to the first element and one past the last element we want to copy respectively. Both methods need to return atleast an InputIterator, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Data container with <a class="el" href="classContainer.html#a48596c6b1d1e0cd8d40bc9a8945726d2" title="Returns an iterator to the first element of the underlying data container. If the array is empty,...">cbegin()</a> and <a class="el" href="classContainer.html#a9041ff5ab8770ed91e7af4769a666604" title="Returns a iterator to one-past-the-last element of the underlying data container.">cend()</a> method that we want to copy fully into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af9c58292cece2339a29060f89d745b35" name="af9c58292cece2339a29060f89d745b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c58292cece2339a29060f89d745b35">&#9670;&#160;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="classContainer.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ab289861d88170c61978e2a91be7e8e48" name="ab289861d88170c61978e2a91be7e8e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab289861d88170c61978e2a91be7e8e48">&#9670;&#160;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all elements from the given start to exclusively the given end iterator into the underlying data container. Simply forwards the arguments to the insert method, meaning if the initally allocated Capacity is not big enough to hold all elements, then this method will assert and stop the application.  </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that allows for forward incrementable access to data of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to one past the end of the elements we want to copy into our underlying data container   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a370bf8739915fe6ec8849d3a95380a96" name="a370bf8739915fe6ec8849d3a95380a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370bf8739915fe6ec8849d3a95380a96">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index, with bounds checking. </p>
<dl class="section note"><dt>Note</dt><dd>If index is not within the range of the container, this method will assert and halt the application </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the element to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69fa8ef8e94069a3a64d7753ab3de66d" name="a69fa8ef8e94069a3a64d7753ab3de66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fa8ef8e94069a3a64d7753ab3de66d">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index, with bounds checking.  </p>
<dl class="section note"><dt>Note</dt><dd>If index is not within the range of the container, this method will assert and halt the application </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the element to return   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26efbb1e96c96265bffd4e51399f4687" name="a26efbb1e96c96265bffd4e51399f4687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26efbb1e96c96265bffd4e51399f4687">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element of the array </dd></dl>

</div>
</div>
<a id="ac86f230ade93a3eb9db1ba8baa355253" name="ac86f230ade93a3eb9db1ba8baa355253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86f230ade93a3eb9db1ba8baa355253">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return.  </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element of the array   </dd></dl>

</div>
</div>
<a id="a30c27fa69e488c3efd6cc23e0df0b89e" name="a30c27fa69e488c3efd6cc23e0df0b89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c27fa69e488c3efd6cc23e0df0b89e">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#aab91ce398967722dc934b52dd75bbdea">iterator</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the underlying data container. If the array is empty, the returned iterator will be equal to <a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a" title="Returns a iterator to one-past-the-last element of the underlying data container.">end()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element of the underlying data container </dd></dl>

</div>
</div>
<a id="a84c9f9c774651788c2071207a3728647" name="a84c9f9c774651788c2071207a3728647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c9f9c774651788c2071207a3728647">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the underlying data container. If the array is empty, the returned iterator will be equal to <a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a" title="Returns a iterator to one-past-the-last element of the underlying data container.">end()</a>  </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element of the underlying data container   </dd></dl>

</div>
</div>
<a id="a4bc44dcdb6b2a7c2e3bf5e68aae26bef" name="a4bc44dcdb6b2a7c2e3bf5e68aae26bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc44dcdb6b2a7c2e3bf5e68aae26bef">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> constexpr <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum amount of elements that can be stored in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum amount of items that can be stored in the underlying data container </dd></dl>

</div>
</div>
<a id="a48596c6b1d1e0cd8d40bc9a8945726d2" name="a48596c6b1d1e0cd8d40bc9a8945726d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48596c6b1d1e0cd8d40bc9a8945726d2">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the underlying data container. If the array is empty, the returned iterator will be equal to <a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a" title="Returns a iterator to one-past-the-last element of the underlying data container.">end()</a>  </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element of the underlying data container   </dd></dl>

</div>
</div>
<a id="a9041ff5ab8770ed91e7af4769a666604" name="a9041ff5ab8770ed91e7af4769a666604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9041ff5ab8770ed91e7af4769a666604">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a iterator to one-past-the-last element of the underlying data container.  </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to one-past-the-last element of the underlying data container   </dd></dl>

</div>
</div>
<a id="aa5bcd6ef4952381b900b980d1847c51c" name="aa5bcd6ef4952381b900b980d1847c51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bcd6ef4952381b900b980d1847c51c">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. After this call, <a class="el" href="classContainer.html#a2032a9a1e12c804da4137cfc0d44b988" title="Gets the current amount of elements in the underlying data container.">size()</a> returns zero. </p>
<dl class="section note"><dt>Note</dt><dd>Simply sets the underlying size to 0, data will only be cleared in the destructor or if new data is inserted, which will overwrite old data. Therefore the user is also cautioned if the element is itself a pointer, the pointed-to memory is not touched in any way </dd></dl>

</div>
</div>
<a id="a8befe721dabf1892cd30a3d1c539a8c1" name="a8befe721dabf1892cd30a3d1c539a8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8befe721dabf1892cd30a3d1c539a8c1">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether there are any elements in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the underlying data container is empty or not </dd></dl>

</div>
</div>
<a id="abc4721c10206d7d9762ce393ae6bcf3a" name="abc4721c10206d7d9762ce393ae6bcf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4721c10206d7d9762ce393ae6bcf3a">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#aab91ce398967722dc934b52dd75bbdea">iterator</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a iterator to one-past-the-last element of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to one-past-the-last element of the underlying data container </dd></dl>

</div>
</div>
<a id="aea94941f62f3dceffb980c2f747fcbeb" name="aea94941f62f3dceffb980c2f747fcbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea94941f62f3dceffb980c2f747fcbeb">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a iterator to one-past-the-last element of the underlying data container.  </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to one-past-the-last element of the underlying data container   </dd></dl>

</div>
</div>
<a id="a3e2c92a9e10fcbb1b978ac943bbc38a3" name="a3e2c92a9e10fcbb1b978ac943bbc38a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2c92a9e10fcbb1b978ac943bbc38a3">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#a7f8a5d2c4c05b7f42db6904d699eb34c">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at the given position, has to move all element one to the left if the iterator does not point to the last valid element in the underlying data container. </p>
<dl class="section note"><dt>Note</dt><dd>The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. Furthermore this method will assert if the position iterator is outside the range of this container, meaning if we are using an iterator to another container or if we passed an invalid iterator that would cause invalid memory access if dereferenced </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that allows for forward incrementable access to data of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to the element, that should be removed from the underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ac1a8dbeee080de605f1ccd8dc9d16" name="a32ac1a8dbeee080de605f1ccd8dc9d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ac1a8dbeee080de605f1ccd8dc9d16">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element of the array </dd></dl>

</div>
</div>
<a id="abcc9f6a5119af7ba2051c04ca5b06707" name="abcc9f6a5119af7ba2051c04ca5b06707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc9f6a5119af7ba2051c04ca5b06707">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element of the array. If the array is empty this method will assert and stop the application, because there is no valid element to return.  </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element of the array   </dd></dl>

</div>
</div>
<a id="a420e3d5aa4d0c0e4b74a2b0b8ac07b0e" name="a420e3d5aa4d0c0e4b74a2b0b8ac07b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420e3d5aa4d0c0e4b74a2b0b8ac07b0e">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#aab91ce398967722dc934b52dd75bbdea">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all elements from the given start to exclusively the given end iterator into the underlying data container. The copying is started from the position before the given iterator (position - 1) </p>
<dl class="section note"><dt>Note</dt><dd>If the position before the iterator (position - 1) is outside the range of this container the method will assert, meaning if we are using an iterator to another container or if we passed an invalid iterator that would cause invalid memory access if dereferenced. Additionally, if the <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> was compiled with THINGSBOARD_ENABLE_DYNAMIC set, then the method will simply increase the capacity exponentially if it is full. Otherwise if the initally allocated Capacity is not big enough to hold all elements, this method will assert and stop the application </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that allows for forward incrementable access to data of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator before which the content will be copied too. May be the <a class="el" href="classContainer.html#abc4721c10206d7d9762ce393ae6bcf3a" title="Returns a iterator to one-past-the-last element of the underlying data container.">end()</a> iterator </td></tr>
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to one past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97b0a941bcf514063a35c7905f923e06" name="a97b0a941bcf514063a35c7905f923e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b0a941bcf514063a35c7905f923e06">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a97344a48f63bbe89812b43d4b5b8c705">reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="section note"><dt>Note</dt><dd>Is more efficient but it is possible to read out of bounds data, which is undefined behaviour </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the element to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addc1204725965a5d9f55717b39f797d0" name="addc1204725965a5d9f55717b39f797d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc1204725965a5d9f55717b39f797d0">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed.  </p>
<dl class="section note"><dt>Note</dt><dd>Is more efficient but it is possible to read out of bounds data, which is undefined behaviour </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the element to return   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e686e24111437e2c0e013ca3e5c9856" name="a4e686e24111437e2c0e013ca3e5c9856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e686e24111437e2c0e013ca3e5c9856">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classContainer.html#a9972975421e7883e72dc98e170895e35">const_reference</a>&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element at the end of the underlying data container. </p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> was compiled with THINGSBOARD_ENABLE_DYNAMIC set, then the method will simply increase the capacity exponentially if it is full. Otherwise if the interal data structure is full this method will assert and stop the application. Because if we do not we could cause an out of bounds write, which could possibly overwrite other memory. Causing hard to debug issues, therefore this behaviour is not allowed in the first place </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element that should be inserted at the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2032a9a1e12c804da4137cfc0d44b988" name="a2032a9a1e12c804da4137cfc0d44b988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2032a9a1e12c804da4137cfc0d44b988">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="classsize__t.html">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classContainer.html#acc84beaceafb25895a751f278feb3370">size_type</a> <a class="el" href="classContainer.html">Container</a>&lt; T, Capacity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current amount of elements in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The amount of items currently in the underlying data container </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Container_8h_source.html">Container.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
