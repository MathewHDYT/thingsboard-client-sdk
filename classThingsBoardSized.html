<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: ThingsBoardSized&lt; MaxResponse, MaxEndpointsAmount, Logger &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.16.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classThingsBoardSized-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ThingsBoardSized&lt; MaxResponse, MaxEndpointsAmount, Logger &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wrapper around any arbitrary MQTT Client implementing the <a class="el" href="classIMQTT__Client.html" title="MQTT Client interface that contains the method that a class that can be used to send and receive data...">IMQTT_Client</a> interface, to allow connecting and sending / retrieving data from ThingsBoard over the MQTT or MQTT with TLS/SSL protocol.  
 <a href="classThingsBoardSized.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ThingsBoard_8h_source.html">ThingsBoard.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a49c09ddd8004e039425291db42727896"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a49c09ddd8004e039425291db42727896"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a49c09ddd8004e039425291db42727896">ThingsBoardSized</a> (<a class="el" href="classIMQTT__Client.html">IMQTT_Client</a> &amp;client, uint16_t receive_buffer_size=<a class="el" href="Constants_8h.html#aa447eab183c7058235fc69a7db8d3fbd">DEFAULT_PAYLOAD_SIZE</a>, uint16_t send_buffer_size=<a class="el" href="Constants_8h.html#aa447eab183c7058235fc69a7db8d3fbd">DEFAULT_PAYLOAD_SIZE</a>, <a class="el" href="classsize__t.html">size_t</a> const &amp;max_stack_size=<a class="el" href="Constants_8h.html#ae91c5575bd5d907935072424dc437ab7">DEFAULT_MAX_STACK_SIZE</a>, Args const &amp;... args)</td></tr>
<tr class="memdesc:a49c09ddd8004e039425291db42727896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a instance with the given network client that should be used to establish the connection to ThingsBoard.  <a href="classThingsBoardSized.html#a49c09ddd8004e039425291db42727896">More...</a><br /></td></tr>
<tr class="separator:a49c09ddd8004e039425291db42727896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3654bc0d6c900b3072b516f914761c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIMQTT__Client.html">IMQTT_Client</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#aa3654bc0d6c900b3072b516f914761c5">Get_Client</a> ()</td></tr>
<tr class="memdesc:aa3654bc0d6c900b3072b516f914761c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the registered underlying MQTT Client implementation.  <a href="classThingsBoardSized.html#aa3654bc0d6c900b3072b516f914761c5">More...</a><br /></td></tr>
<tr class="separator:aa3654bc0d6c900b3072b516f914761c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d1a5d19663099be779c4be769bdcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a108d1a5d19663099be779c4be769bdcb">Set_Maximum_Stack_Size</a> (<a class="el" href="classsize__t.html">size_t</a> const &amp;max_stack_size)</td></tr>
<tr class="memdesc:a108d1a5d19663099be779c4be769bdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead.  <a href="classThingsBoardSized.html#a108d1a5d19663099be779c4be769bdcb">More...</a><br /></td></tr>
<tr class="separator:a108d1a5d19663099be779c4be769bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027a2d46d4f3b620fa36bb7603441a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a027a2d46d4f3b620fa36bb7603441a16">Get_Maximum_Stack_Size</a> () const</td></tr>
<tr class="memdesc:a027a2d46d4f3b620fa36bb7603441a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead.  <a href="classThingsBoardSized.html#a027a2d46d4f3b620fa36bb7603441a16">More...</a><br /></td></tr>
<tr class="separator:a027a2d46d4f3b620fa36bb7603441a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d462aae65f6948dc02235ad4bc824"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a454d462aae65f6948dc02235ad4bc824">Set_Buffer_Size</a> (uint16_t receive_buffer_size, uint16_t send_buffer_size)</td></tr>
<tr class="memdesc:a454d462aae65f6948dc02235ad4bc824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the buffer for sent and received MQTT messages.   <a href="classThingsBoardSized.html#a454d462aae65f6948dc02235ad4bc824">More...</a><br /></td></tr>
<tr class="separator:a454d462aae65f6948dc02235ad4bc824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db6bb0a31d248cad243567a2483ac3c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a5db6bb0a31d248cad243567a2483ac3c">Get_Receive_Buffer_Size</a> ()</td></tr>
<tr class="memdesc:a5db6bb0a31d248cad243567a2483ac3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previously set size of the internal buffer size meant for incoming MQTT data.   <a href="classThingsBoardSized.html#a5db6bb0a31d248cad243567a2483ac3c">More...</a><br /></td></tr>
<tr class="separator:a5db6bb0a31d248cad243567a2483ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd547136d7819fc1b354dd07ed88d1bf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#abd547136d7819fc1b354dd07ed88d1bf">Get_Send_Buffer_Size</a> ()</td></tr>
<tr class="memdesc:abd547136d7819fc1b354dd07ed88d1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previously set size of the internal buffer size meant for outgoing MQTT data.   <a href="classThingsBoardSized.html#abd547136d7819fc1b354dd07ed88d1bf">More...</a><br /></td></tr>
<tr class="separator:abd547136d7819fc1b354dd07ed88d1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4397300dbe8bd707a6ac384340ae28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#afe4397300dbe8bd707a6ac384340ae28">Cleanup_Subscriptions</a> ()</td></tr>
<tr class="memdesc:afe4397300dbe8bd707a6ac384340ae28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all currently subscribed callbacks and unsubscribed from all currently subscribed MQTT topics.  <a href="classThingsBoardSized.html#afe4397300dbe8bd707a6ac384340ae28">More...</a><br /></td></tr>
<tr class="separator:afe4397300dbe8bd707a6ac384340ae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb2a960139ec1b5666f7965d97a5c5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a1bb2a960139ec1b5666f7965d97a5c5f">connect</a> (char const *host, char const *access_token=<a class="el" href="ThingsBoard_8h.html#a77eb7e34725a25278e1f3e415a815a0e">PROV_ACCESS_TOKEN</a>, uint16_t port=<a class="el" href="ThingsBoard_8h.html#a19cbbc752570b6332457567197228bb7">DEFAULT_MQTT_PORT</a>, char const *client_id=nullptr, char const *password=nullptr)</td></tr>
<tr class="memdesc:a1bb2a960139ec1b5666f7965d97a5c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to the given server instance and port with the given credentials.  <a href="classThingsBoardSized.html#a1bb2a960139ec1b5666f7965d97a5c5f">More...</a><br /></td></tr>
<tr class="separator:a1bb2a960139ec1b5666f7965d97a5c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e498c0d72b19ed14c9ab15e1c3a950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#ae1e498c0d72b19ed14c9ab15e1c3a950">disconnect</a> ()</td></tr>
<tr class="memdesc:ae1e498c0d72b19ed14c9ab15e1c3a950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force disconnects from the previously connected server and should release all used resources.   <a href="classThingsBoardSized.html#ae1e498c0d72b19ed14c9ab15e1c3a950">More...</a><br /></td></tr>
<tr class="separator:ae1e498c0d72b19ed14c9ab15e1c3a950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae433b17ad78ef5699f6e672c01e9d6f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#ae433b17ad78ef5699f6e672c01e9d6f6">connected</a> ()</td></tr>
<tr class="memdesc:ae433b17ad78ef5699f6e672c01e9d6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet.   <a href="classThingsBoardSized.html#ae433b17ad78ef5699f6e672c01e9d6f6">More...</a><br /></td></tr>
<tr class="separator:ae433b17ad78ef5699f6e672c01e9d6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38859fae703b9afbd8dba0ec77a47f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#aa38859fae703b9afbd8dba0ec77a47f8">Get_Connection_State</a> ()</td></tr>
<tr class="memdesc:aa38859fae703b9afbd8dba0ec77a47f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current connection state to the server includes possible intermediate states between connecting and disconnecting.   <a href="classThingsBoardSized.html#aa38859fae703b9afbd8dba0ec77a47f8">More...</a><br /></td></tr>
<tr class="separator:aa38859fae703b9afbd8dba0ec77a47f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd1877449a855a43582d86a25348fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a41bd1877449a855a43582d86a25348fd">Get_Last_Connection_Error</a> ()</td></tr>
<tr class="memdesc:a41bd1877449a855a43582d86a25348fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to deciper the reason for a failure, while attempting to establish a connection to the MQTT broker.   <a href="classThingsBoardSized.html#a41bd1877449a855a43582d86a25348fd">More...</a><br /></td></tr>
<tr class="separator:a41bd1877449a855a43582d86a25348fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e455a7e09a73e27b7b95d3d6e622ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a27e455a7e09a73e27b7b95d3d6e622ae">Subscribe_Connection_State_Changed_Callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a>, <a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a> &gt;::function callback)</td></tr>
<tr class="memdesc:a27e455a7e09a73e27b7b95d3d6e622ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, whenever the underlying state of our connection with the MQTT broker changes.   <a href="classThingsBoardSized.html#a27e455a7e09a73e27b7b95d3d6e622ae">More...</a><br /></td></tr>
<tr class="separator:a27e455a7e09a73e27b7b95d3d6e622ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c40ea375b118c4c9864c75c55ee4cc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a6c40ea375b118c4c9864c75c55ee4cc3">loop</a> ()</td></tr>
<tr class="memdesc:a6c40ea375b118c4c9864c75c55ee4cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives / sends any outstanding messages from and to the MQTT broker.   <a href="classThingsBoardSized.html#a6c40ea375b118c4c9864c75c55ee4cc3">More...</a><br /></td></tr>
<tr class="separator:a6c40ea375b118c4c9864c75c55ee4cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0c1cfbce0cbcfca56ed912e954cfa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a1a0c1cfbce0cbcfca56ed912e954cfa9">Send_Json</a> (char const *topic, JsonDocument const &amp;source)</td></tr>
<tr class="memdesc:a1a0c1cfbce0cbcfca56ed912e954cfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends key-value pairs from the given JsonDocument over the given topic.  <a href="classThingsBoardSized.html#a1a0c1cfbce0cbcfca56ed912e954cfa9">More...</a><br /></td></tr>
<tr class="separator:a1a0c1cfbce0cbcfca56ed912e954cfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e3e88d7b297ad4d38a6418171edee8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a17e3e88d7b297ad4d38a6418171edee8">Send_Json_String</a> (char const *topic, char const *json)</td></tr>
<tr class="memdesc:a17e3e88d7b297ad4d38a6418171edee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends key-value pairs from the given json string over the given topic.  <a href="classThingsBoardSized.html#a17e3e88d7b297ad4d38a6418171edee8">More...</a><br /></td></tr>
<tr class="separator:a17e3e88d7b297ad4d38a6418171edee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac163154d027781fd48b7905ec4a4f4bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#ac163154d027781fd48b7905ec4a4f4bb">Subscribe_API_Implementation</a> (<a class="el" href="classIAPI__Implementation.html">IAPI_Implementation</a> &amp;api)</td></tr>
<tr class="memdesc:ac163154d027781fd48b7905ec4a4f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes the given API implementation.  <a href="classThingsBoardSized.html#ac163154d027781fd48b7905ec4a4f4bb">More...</a><br /></td></tr>
<tr class="separator:ac163154d027781fd48b7905ec4a4f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab921a6b407322a6136cb700f1e28c5e3"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab921a6b407322a6136cb700f1e28c5e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#ab921a6b407322a6136cb700f1e28c5e3">Subscribe_API_Implementations</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:ab921a6b407322a6136cb700f1e28c5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes the given API implementation.  <a href="classThingsBoardSized.html#ab921a6b407322a6136cb700f1e28c5e3">More...</a><br /></td></tr>
<tr class="separator:ab921a6b407322a6136cb700f1e28c5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b383bfa3407ae94bedd17b317b4210"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a27b383bfa3407ae94bedd17b317b4210">Claim_Request</a> (<a class="el" href="classsize__t.html">size_t</a> const &amp;duration_ms, char const *secret_key=nullptr)</td></tr>
<tr class="memdesc:a27b383bfa3407ae94bedd17b317b4210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a claiming request for this device.  <a href="classThingsBoardSized.html#a27b383bfa3407ae94bedd17b317b4210">More...</a><br /></td></tr>
<tr class="separator:a27b383bfa3407ae94bedd17b317b4210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadd9aa2ccca2e61b5465a239eec367c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeadd9aa2ccca2e61b5465a239eec367c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#aeadd9aa2ccca2e61b5465a239eec367c">Send_Telemetry_Data</a> (char const *key, T const &amp;value)</td></tr>
<tr class="memdesc:aeadd9aa2ccca2e61b5465a239eec367c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given key-value pair as telemetry data. See <a href="https://thingsboard.io/docs/user-guide/telemetry/">https://thingsboard.io/docs/user-guide/telemetry/</a> for more information.  <a href="classThingsBoardSized.html#aeadd9aa2ccca2e61b5465a239eec367c">More...</a><br /></td></tr>
<tr class="separator:aeadd9aa2ccca2e61b5465a239eec367c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d29cd74bec00f18853c729716e58c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxKeyValuePairAmount, typename InputIterator &gt; </td></tr>
<tr class="memitem:aa9d29cd74bec00f18853c729716e58c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#aa9d29cd74bec00f18853c729716e58c3">Send_Telemetry</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:aa9d29cd74bec00f18853c729716e58c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send aggregated key-value pair as telemetry data.  <a href="classThingsBoardSized.html#aa9d29cd74bec00f18853c729716e58c3">More...</a><br /></td></tr>
<tr class="separator:aa9d29cd74bec00f18853c729716e58c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0796d1f7df1f1d7a4a5036098d64894c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a0796d1f7df1f1d7a4a5036098d64894c">Send_Telemetry_String</a> (char const *json)</td></tr>
<tr class="memdesc:a0796d1f7df1f1d7a4a5036098d64894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send string containing json as telemetry data. See <a href="https://thingsboard.io/docs/user-guide/telemetry/">https://thingsboard.io/docs/user-guide/telemetry/</a> for more information.  <a href="classThingsBoardSized.html#a0796d1f7df1f1d7a4a5036098d64894c">More...</a><br /></td></tr>
<tr class="separator:a0796d1f7df1f1d7a4a5036098d64894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6130abe5e3ad329ae0f90b943bb440e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#af6130abe5e3ad329ae0f90b943bb440e">Send_Telemetry_Json</a> (JsonDocument const &amp;source)</td></tr>
<tr class="memdesc:af6130abe5e3ad329ae0f90b943bb440e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send key-value pairs as telemetry data. See <a href="https://thingsboard.io/docs/user-guide/telemetry/">https://thingsboard.io/docs/user-guide/telemetry/</a> for more information.  <a href="classThingsBoardSized.html#af6130abe5e3ad329ae0f90b943bb440e">More...</a><br /></td></tr>
<tr class="separator:af6130abe5e3ad329ae0f90b943bb440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859b3fd2f0c735b4db6de6a4374012cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a859b3fd2f0c735b4db6de6a4374012cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a859b3fd2f0c735b4db6de6a4374012cc">Send_Attribute_Data</a> (char const *key, T const &amp;value)</td></tr>
<tr class="memdesc:a859b3fd2f0c735b4db6de6a4374012cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given key-value pair as attribute data. See <a href="https://thingsboard.io/docs/user-guide/attributes/">https://thingsboard.io/docs/user-guide/attributes/</a> for more information.  <a href="classThingsBoardSized.html#a859b3fd2f0c735b4db6de6a4374012cc">More...</a><br /></td></tr>
<tr class="separator:a859b3fd2f0c735b4db6de6a4374012cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9971d72353af88de43ae9d00ddf82f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxKeyValuePairAmount, typename InputIterator &gt; </td></tr>
<tr class="memitem:a0e9971d72353af88de43ae9d00ddf82f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a0e9971d72353af88de43ae9d00ddf82f">Send_Attributes</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:a0e9971d72353af88de43ae9d00ddf82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send aggregated key-value pair as attribute data.  <a href="classThingsBoardSized.html#a0e9971d72353af88de43ae9d00ddf82f">More...</a><br /></td></tr>
<tr class="separator:a0e9971d72353af88de43ae9d00ddf82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba8b73e99e7092172d0309dd5e50b69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#aeba8b73e99e7092172d0309dd5e50b69">Send_Attribute_String</a> (char const *json)</td></tr>
<tr class="memdesc:aeba8b73e99e7092172d0309dd5e50b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send string containing json as attribute data. See <a href="https://thingsboard.io/docs/user-guide/attribute/">https://thingsboard.io/docs/user-guide/attribute/</a> for more information.  <a href="classThingsBoardSized.html#aeba8b73e99e7092172d0309dd5e50b69">More...</a><br /></td></tr>
<tr class="separator:aeba8b73e99e7092172d0309dd5e50b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8ddbd49ec345c96d25f400767481bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThingsBoardSized.html#a1d8ddbd49ec345c96d25f400767481bb">Send_Attribute_Json</a> (JsonDocument const &amp;source)</td></tr>
<tr class="memdesc:a1d8ddbd49ec345c96d25f400767481bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send key-value pairs as attribute data. See <a href="https://thingsboard.io/docs/user-guide/attribute/">https://thingsboard.io/docs/user-guide/attribute/</a> for more information.  <a href="classThingsBoardSized.html#a1d8ddbd49ec345c96d25f400767481bb">More...</a><br /></td></tr>
<tr class="separator:a1d8ddbd49ec345c96d25f400767481bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger = DefaultLogger&gt;<br />
class ThingsBoardSized&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;</div><p >Wrapper around any arbitrary MQTT Client implementing the <a class="el" href="classIMQTT__Client.html" title="MQTT Client interface that contains the method that a class that can be used to send and receive data...">IMQTT_Client</a> interface, to allow connecting and sending / retrieving data from ThingsBoard over the MQTT or MQTT with TLS/SSL protocol. </p>
<dl class="section note"><dt>Note</dt><dd>BufferSize of the underlying data buffer can be changed during the runtime and the maximum amount of data points that can ever be can be set once as template argument. Additionally, there are internal arrays that hold all subscriptions and requests and statically allocate memory on the stack, which can also be set once as a template argument. Furthermore, there are the maximum amount of values for the internal arrays of the <a class="el" href="classShared__Attribute__Callback.html" title="Shared attribute update callback wrapper, contains the needed configuration settings to create the re...">Shared_Attribute_Callback</a> and the <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a>, which hold the amount of keys we want to request or subscribe to updates too Setting a fixed size, allows to allocate the variables in the container on the stack, which can also be set once as a template argument. Changing is only possible if a new instance of this class is created. If these values should be automatically deduced at runtime and the values dynamically allocated on the heap instead, removing the need to declare them at compile time, simply set THINGSBOARD_ENABLE_DYNAMIC to 1, before including <a class="el" href="ThingsBoard_8h.html">ThingsBoard.h</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MaxResponse</td><td>Maximum amount of key-value pairs that will ever be received by ThingsBoard in one call, default = DEFAULT_RESPONSE_AMOUNT (8) </td></tr>
    <tr><td class="paramname">MaxEndpointsAmount</td><td>Maximum amount of subscribed API endpoints, DEFAULT_ENDPOINT_AMOUNT is used as the default value because it is big enough to hold one instance of every possible API Implementation, default = DEFAULT_ENDPOINT_AMOUNT (7) </td></tr>
    <tr><td class="paramname">Logger</td><td>Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = <a class="el" href="classDefaultLogger.html" title="Default logger class used by the ThingsBoard class to log messages into the console output.">DefaultLogger</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a49c09ddd8004e039425291db42727896" name="a49c09ddd8004e039425291db42727896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c09ddd8004e039425291db42727896">&#9670;&#160;</a></span>ThingsBoardSized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;<a class="el" href="classThingsBoardSized.html">::ThingsBoardSized</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIMQTT__Client.html">IMQTT_Client</a> &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>receive_buffer_size</em> = <code><a class="el" href="Constants_8h.html#aa447eab183c7058235fc69a7db8d3fbd">DEFAULT_PAYLOAD_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>send_buffer_size</em> = <code><a class="el" href="Constants_8h.html#aa447eab183c7058235fc69a7db8d3fbd">DEFAULT_PAYLOAD_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>max_stack_size</em> = <code><a class="el" href="Constants_8h.html#ae91c5575bd5d907935072424dc437ab7">DEFAULT_MAX_STACK_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a instance with the given network client that should be used to establish the connection to ThingsBoard. </p>
<dl class="section note"><dt>Note</dt><dd>Directly forwards the given arguments to the overloaded <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> constructor, meaning all combinatons of arguments that would initalize an std::vector can be used to call this constructor. See possible std::vector constructors here <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>, for the possible passable parameters. The possibilites mainly consist out of the fill constructor, where a number n and a value is given and then the value is copied into that many elements, alternatively if no value is given the default constructed value is copied n times instead, or the range constructor where we can pass an interator to the start and to the end of the data container (last element + 1) to copy every element in between thoose iterators, in the same order as in the original data container. The last option is a copy constructor where we pass another container and all the values of that container will be copied into our buffer </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the container constructor and therefore allow to use every overloaded constructor without having to explicitly implement them </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>MQTT Client implementation that should be used to establish the connection to ThingsBoard </td></tr>
    <tr><td class="paramname">receive_buffer_size</td><td>Maximum amount of data that can be received via MQTT at once, expected behaviour is that, if bigger packets are received they are discarded and a warning is printed to the console. Should be big enough to hold the biggest response that is expected to be ever received by the device at once, default = DEFAULT_PAYLOAD_SIZE (64) </td></tr>
    <tr><td class="paramname">send_buffer_size</td><td>Maximum amount of data that can be sent via MQTT at once, expected behaviour is that, if we attempt to send data that is bigger, it will simply not be sent and a message is printed to the console instead. Should be big enough to hold the biggest request that is expected to be ever sent by the device at once. Alternatively when using Arduino it is possible to enable support for THINGSBOARD_ENABLE_STREAM_UTILS by importing the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) in the project. This feature allows to improve the underlying data streams by directly writing the data into the MQTT Client instead of into an output buffer, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint, which only exists on Arduino This then allows to send arbitrary size payloads if that is done the internal buffer of the MQTT Client implementation can theoretically set the value as big as the buffering_size passed to the constructor + enough memory to hold the topic and MQTT Header ~= 20 bytes. This will mean though that all messages are sent over the StreamUtils library as long as they are bigger than the internal send buffer size, which needs more time than sending a message directly but has the advantage of requiring less memory, default = DEFAULT_PAYLOAD_SIZE (64) </td></tr>
    <tr><td class="paramname">max_stack_size</td><td>Maximum amount of bytes we want to allocate on the stack. Is used when sending a lot of data at once over MQTT, because to actually send the JsonDocument data it first has to be serialized into a json string payload. To achieve this the data contained in the JsonDocument is copied for the scope of the <a class="el" href="classThingsBoardSized.html#a1a0c1cfbce0cbcfca56ed912e954cfa9">Send_Json</a> method and is then copied into the outgoing MQTT buffer. This variable therefore decides the threshold where the JsonDocument is copied into the heap instead of a object on the stack. This is created to ensure no StackOverflow occurs because most supported boards run the actual sending code in a seperate FreeRTOS Task with limited stack space where even a stack allocation of 4 KiB might already cause a crash To circumvent this copy the alternative mentioned in the send_buffer_size argument can also be used because it skips the internal copy alltogether, because the JsonDocument is instead directly copied into the outgoing MQTT buffer, default = DEFAULT_MAX_STACK_SIZE (1024) </td></tr>
    <tr><td class="paramname">max_response_size</td><td>Maximum amount of bytes allocated for the interal JsonDocument structure that holds the received payload. Size is calculated automatically from certain characters in the received payload (',', '{', '[') but if we receive a malicious payload that contains these symbols in a string {"example":",,,,,,..."}. It is possible to cause huge allocations, but because the memory only lives for as long as the subscribed callback methods it should not be a problem, especially because attempting to allocate too much memory, will cause the allocation to fail, which is checked. But if the failure of that heap allocation is subscribed for example with the heap_caps_register_failed_alloc_callback method on the ESP32, then that subscribed callback will be called and could theoretically restart the device. To circumvent that we can simply set the size of this variable to a value that should never be exceeded by a non malicious json payload. If this safety feature is not required, because the heap allocation failure callback is not subscribed, then the value of the variable can simply be kept as 0, which means we will not check the received payload for its size before the allocation happens, default = DEFAULT_MAX_RESPONSE_SIZE (0) </td></tr>
    <tr><td class="paramname">buffering_size</td><td>Amount of bytes allocated to speed up serialization. Used when THINGSBOARD_ENABLE_STREAM_UTILS is enabled by importing the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) in the project. This feature allows to improve the underlying data streams by directly writing the data into the MQTT Client instead of into an output buffer, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. The variable therefore decides the exact buffering size for these packets, where bigger packets cause faster serialization but in exchange require more memory, default = DEFAULT_BUFFERING_SIZE (64) </td></tr>
    <tr><td class="paramname">...args</td><td>APIs that should be connected to ThingsBoard and therefore be able to send and receive data over MQTT, that will be forwarded into the overloaded <a class="el" href="classContainer.html" title="Custom std::array or std::vector implementation that contains a partial vector-like interface impleme...">Container</a> constructor see <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a> for more information. Ensure the actual API implementations are kept alive as long as the instance of this class. Because the values are not copied, but a non owning pointers to the values are inserted into the local container member variable instead </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27b383bfa3407ae94bedd17b317b4210" name="a27b383bfa3407ae94bedd17b317b4210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b383bfa3407ae94bedd17b317b4210">&#9670;&#160;</a></span>Claim_Request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Claim_Request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>duration_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>secret_key</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a claiming request for this device. </p>
<dl class="section note"><dt>Note</dt><dd>Allows any user registered on the cloud to assign the device as their own (claim), as long as they enter the given corresponding device name and secret key in the given amount of time. Optionally the secret key can be left empty, results in the cloud allowing any user to claim the device without the need to enter a secret key. See <a href="https://thingsboard.io/docs/user-guide/claiming-devices/">https://thingsboard.io/docs/user-guide/claiming-devices/</a> for more information </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration_ms</td><td>Total time in milliseconds that the device can be claimed for. If the device is not claimed in the given timeframe then another claiming request would need to be sent to allow for the device to be claimed again </td></tr>
    <tr><td class="paramname">secret_key</td><td>Non owning pointer to the password that needs to be entered to claim the device. Functions as an additional security mechanism to only allow the actual inteded user to claim the device. If this feature is not needed and claiming without the password is wanted simply pass a nullptr or empty string as the argument instead. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the claiming request, default = nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the created claiming request into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="afe4397300dbe8bd707a6ac384340ae28" name="afe4397300dbe8bd707a6ac384340ae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4397300dbe8bd707a6ac384340ae28">&#9670;&#160;</a></span>Cleanup_Subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Cleanup_Subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all currently subscribed callbacks and unsubscribed from all currently subscribed MQTT topics. </p>
<dl class="section note"><dt>Note</dt><dd>Any response that will stil be received is discarded and any ongoing firmware update is aborted and will not be finished. Was done automatically in the <a class="el" href="classThingsBoardSized.html#a1bb2a960139ec1b5666f7965d97a5c5f" title="Connects to the given server instance and port with the given credentials.">connect()</a> method in previous versions of the library, but is not done anymore, because <a class="el" href="classThingsBoardSized.html#a1bb2a960139ec1b5666f7965d97a5c5f" title="Connects to the given server instance and port with the given credentials.">connect()</a> method now reconencts to all previously subscribed MQTT topics instead, therefore there is no need anymore to discard all previously subscribed callbacks and letting the user resubscribe by hand themselves, because that resubscription is now handled automatically. But to allow for the use case of complete unsubscriptions this method still exists </dd></dl>

</div>
</div>
<a id="a1bb2a960139ec1b5666f7965d97a5c5f" name="a1bb2a960139ec1b5666f7965d97a5c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb2a960139ec1b5666f7965d97a5c5f">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>access_token</em> = <code><a class="el" href="ThingsBoard_8h.html#a77eb7e34725a25278e1f3e415a815a0e">PROV_ACCESS_TOKEN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em> = <code><a class="el" href="ThingsBoard_8h.html#a19cbbc752570b6332457567197228bb7">DEFAULT_MQTT_PORT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>client_id</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>password</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects to the given server instance and port with the given credentials. </p>
<dl class="section note"><dt>Note</dt><dd>Additionally internal Containers are not deleted or changed when reconnecting so any permanent subscriptions already previously subscribed, does not need to be resubscribed. Furthermore if there are still any active permanent subscriptions (server-side RPC or shared attribute update subscriptions), the aforementioned topics will be resubscribed automatically as soon as the device has successfully connected. This means that any permanent subscriptions will immediately be notified of any changes again once the device connects. This removes the need to register these callbacks every time the device disconnects and instead can be done once at startup. They can even be subscribed before the device has even connected to the cloud </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Non owning pointer to server instance name the client should connect too. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection </td></tr>
    <tr><td class="paramname">access_token</td><td>Non owning pointer to access token, that allows to differentiate which MQTT device is sending the traffic to the MQTT broker. Can be "provision", if the device creates itself instead. See <a href="https://thingsboard.io/docs/user-guide/device-provisioning/?mqttprovisioning=without#provision-device-apis">https://thingsboard.io/docs/user-guide/device-provisioning/?mqttprovisioning=without#provision-device-apis</a> for more information. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection, default = PROV_ACCESS_TOKEN ("provision") </td></tr>
    <tr><td class="paramname">port</td><td>Port that will be used to establish a connection and send / receive data. Should be either 1883 for unencrypted MQTT or 8883 for MQTT with TLS/SSL encryption. The latter is recommended if relevant data is sent or if the client receives and handles Remote Procedure Calls or Shared Attribute Update Callbacks from the server, because using an unencrpyted connection, will allow 3rd parties to listen to the communication and impersonate the server sending payloads which might influence the device in unexpected ways. However if Over the Air udpates are enabled secure communication should definetly be enabled, because if that is not done a 3rd party might impersonate the server sending a malicious payload, which is then flashed onto the device instead of the real firmware. Which depeding on the payload might even be able to destroy the device or make it otherwise unusable. See <a href="https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/">https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/</a> for more information on the aforementioned security risk, default = DEFAULT_MQTT_PORT (1883) </td></tr>
    <tr><td class="paramname">user_name</td><td>Non owning pointer to client username that is used to authenticate, who is connecting over MQTT. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection, default = nullptr </td></tr>
    <tr><td class="paramname">password</td><td>Non owning pointer to client password that is used to authenticate, who is connecting over MQTT. Additionally it has to be kept alive by the user for the runtime of the MQTT client connection, default = nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether connecting to ThingsBoard was successful or not </dd></dl>

</div>
</div>
<a id="ae433b17ad78ef5699f6e672c01e9d6f6" name="ae433b17ad78ef5699f6e672c01e9d6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae433b17ad78ef5699f6e672c01e9d6f6">&#9670;&#160;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet.  </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the client is currently connected or not   </dd></dl>

</div>
</div>
<a id="ae1e498c0d72b19ed14c9ab15e1c3a950" name="ae1e498c0d72b19ed14c9ab15e1c3a950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e498c0d72b19ed14c9ab15e1c3a950">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force disconnects from the previously connected server and should release all used resources.  </p>
<dl class="section note"><dt>Note</dt><dd>Be aware that Espressif_MQTT_Client automatically reconnects, as long as Espressif_MQTT_Client::set_disable_auto_reconnect was not set to true   </dd></dl>

</div>
</div>
<a id="aa3654bc0d6c900b3072b516f914761c5" name="aa3654bc0d6c900b3072b516f914761c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3654bc0d6c900b3072b516f914761c5">&#9670;&#160;</a></span>Get_Client()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIMQTT__Client.html">IMQTT_Client</a> &amp; <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Get_Client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the registered underlying MQTT Client implementation. </p>
<dl class="section note"><dt>Note</dt><dd>Allows for calling method directly on the client itself, not advised in normal use cases, as it might cause problems if the library expects the client to be sending / receiving data but it can not do that anymore, because it has been disconnected or certain settings were changed </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the registered underlying MQTT Client implementation </dd></dl>

</div>
</div>
<a id="aa38859fae703b9afbd8dba0ec77a47f8" name="aa38859fae703b9afbd8dba0ec77a47f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38859fae703b9afbd8dba0ec77a47f8">&#9670;&#160;</a></span>Get_Connection_State()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a> <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Get_Connection_State </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current connection state to the server includes possible intermediate states between connecting and disconnecting.  </p>
<dl class="section note"><dt>Note</dt><dd>Only the Espressif_MQTT_Client ever returns the intermediate states, because the implementation is non blocking. Meaning calling disconnect will not immediately disconnect from the cloud but instead require a while. In comparsion Arduino_MQTT_Client is blocking, meaning we block until we disconnected or connected. If the ERROR state is returned, the reason for the failed connection can be deciphered more clearly using get_last_connection_error </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The current state of the connection to the MQTT broker   </dd></dl>

</div>
</div>
<a id="a41bd1877449a855a43582d86a25348fd" name="a41bd1877449a855a43582d86a25348fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd1877449a855a43582d86a25348fd">&#9670;&#160;</a></span>Get_Last_Connection_Error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a> <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Get_Last_Connection_Error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to deciper the reason for a failure, while attempting to establish a connection to the MQTT broker.  </p>
<dl class="section note"><dt>Note</dt><dd>Shows the reason for the last failure to connect or the current one, if get_connection_state returns the ERROR state </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last error that occured while attempting to establish a connection to MQTT   </dd></dl>

</div>
</div>
<a id="a027a2d46d4f3b620fa36bb7603441a16" name="a027a2d46d4f3b620fa36bb7603441a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027a2d46d4f3b620fa36bb7603441a16">&#9670;&#160;</a></span>Get_Maximum_Stack_Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsize__t.html">size_t</a> const  &amp; <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Get_Maximum_Stack_Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum amount of bytes we want to allocate on the stack </dd></dl>

</div>
</div>
<a id="a5db6bb0a31d248cad243567a2483ac3c" name="a5db6bb0a31d248cad243567a2483ac3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db6bb0a31d248cad243567a2483ac3c">&#9670;&#160;</a></span>Get_Receive_Buffer_Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Get_Receive_Buffer_Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previously set size of the internal buffer size meant for incoming MQTT data.  </p>
<dl class="section return"><dt>Returns</dt><dd>Internal size of the buffer   </dd></dl>

</div>
</div>
<a id="abd547136d7819fc1b354dd07ed88d1bf" name="abd547136d7819fc1b354dd07ed88d1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd547136d7819fc1b354dd07ed88d1bf">&#9670;&#160;</a></span>Get_Send_Buffer_Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Get_Send_Buffer_Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previously set size of the internal buffer size meant for outgoing MQTT data.  </p>
<dl class="section return"><dt>Returns</dt><dd>Internal size of the buffer   </dd></dl>

</div>
</div>
<a id="a6c40ea375b118c4c9864c75c55ee4cc3" name="a6c40ea375b118c4c9864c75c55ee4cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c40ea375b118c4c9864c75c55ee4cc3">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives / sends any outstanding messages from and to the MQTT broker.  </p>
<dl class="section note"><dt>Note</dt><dd>Only required if the MQTT client is blocking and does not use a seperate task to process messages. This is the case for Arduino_MQTT_Client, which requires calls to this method to actually process the received and sent data. For the Espressif_MQTT_Client however, this method simply does nothing and never needs to be called, because received and set data is processed using a seperate FreeRTOS task </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether sending or receiving the oustanding the messages was successful or not. Returns false if an internal error occured or the connection has been lost. Exact state can be read from get_connection_state and get_last_connection_error   </dd></dl>

</div>
</div>
<a id="a859b3fd2f0c735b4db6de6a4374012cc" name="a859b3fd2f0c735b4db6de6a4374012cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859b3fd2f0c735b4db6de6a4374012cc">&#9670;&#160;</a></span>Send_Attribute_Data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Attribute_Data </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the given key-value pair as attribute data. See <a href="https://thingsboard.io/docs/user-guide/attributes/">https://thingsboard.io/docs/user-guide/attributes/</a> for more information. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the passed value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Non owning pointer to the key of the key-value pair. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the key-value pair </td></tr>
    <tr><td class="paramname">value</td><td>Value of the key-value pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pair into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="a1d8ddbd49ec345c96d25f400767481bb" name="a1d8ddbd49ec345c96d25f400767481bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8ddbd49ec345c96d25f400767481bb">&#9670;&#160;</a></span>Send_Attribute_Json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Attribute_Json </td>
          <td>(</td>
          <td class="paramtype">JsonDocument const &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send key-value pairs as attribute data. See <a href="https://thingsboard.io/docs/user-guide/attribute/">https://thingsboard.io/docs/user-guide/attribute/</a> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>JsonDocument containing our json key-value pairs, is checked before usage for any possible occuring internal errors. See <a href="https://arduinojson.org/v6/api/jsondocument/">https://arduinojson.org/v6/api/jsondocument/</a> for more information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pairs into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="aeba8b73e99e7092172d0309dd5e50b69" name="aeba8b73e99e7092172d0309dd5e50b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba8b73e99e7092172d0309dd5e50b69">&#9670;&#160;</a></span>Send_Attribute_String()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Attribute_String </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send string containing json as attribute data. See <a href="https://thingsboard.io/docs/user-guide/attribute/">https://thingsboard.io/docs/user-guide/attribute/</a> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>Non owning pointer to the string containing our json key-value pairs Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the key-value pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pairs into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="a0e9971d72353af88de43ae9d00ddf82f" name="a0e9971d72353af88de43ae9d00ddf82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9971d72353af88de43ae9d00ddf82f">&#9670;&#160;</a></span>Send_Attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxKeyValuePairAmount, typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Attributes </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send aggregated key-value pair as attribute data. </p>
<dl class="section note"><dt>Note</dt><dd>Expects iterators to a container containing Attribute class instances. See <a href="https://thingsboard.io/docs/user-guide/attribute/">https://thingsboard.io/docs/user-guide/attribute/</a> for more information </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that allows for forward incrementable access to data of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
    <tr><td class="paramname">MaxKeyValuePairAmount</td><td>Maximum amount of key-value pairs, which will ever be sent with this method. Should simply be the biggest distance between first and last iterator this method is ever called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element in the data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the data container (last element + 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pairs into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="a1a0c1cfbce0cbcfca56ed912e954cfa9" name="a1a0c1cfbce0cbcfca56ed912e954cfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0c1cfbce0cbcfca56ed912e954cfa9">&#9670;&#160;</a></span>Send_Json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Json </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonDocument const &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends key-value pairs from the given JsonDocument over the given topic. </p>
<dl class="section note"><dt>Note</dt><dd>The passed JsonDocument data first has to be serialized into a json string payload to be then copied into the outgoing MQTT buffer. To circumvent this copy the alternative mentioned in the send_buffer_size argument of the constructor can also be used because it skips the internal copy alltogether, because the JsonDocument is instead directly copied into the outgoing MQTT buffer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Non owning pointer to topic that the message is sent over, where different MQTT topics expect a different kind of payload. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the given payload </td></tr>
    <tr><td class="paramname">source</td><td>JsonDocument containing our json key-value pairs, is checked before usage for any possible occuring internal errors. See <a href="https://arduinojson.org/v6/api/jsondocument/">https://arduinojson.org/v6/api/jsondocument/</a> for more information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the payload contained in the source into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="a17e3e88d7b297ad4d38a6418171edee8" name="a17e3e88d7b297ad4d38a6418171edee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e3e88d7b297ad4d38a6418171edee8">&#9670;&#160;</a></span>Send_Json_String()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Json_String </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends key-value pairs from the given json string over the given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Non owning pointer to topic that the message is sent over, where different MQTT topics expect a different kind of payload. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the given payload </td></tr>
    <tr><td class="paramname">json</td><td>Non owning pointer to the string containing serialized json key-value pairs that should be copied into the outgoing MQTT buffer. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the given payload </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the payload contained in the json string into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="aa9d29cd74bec00f18853c729716e58c3" name="aa9d29cd74bec00f18853c729716e58c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d29cd74bec00f18853c729716e58c3">&#9670;&#160;</a></span>Send_Telemetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxKeyValuePairAmount, typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Telemetry </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send aggregated key-value pair as telemetry data. </p>
<dl class="section note"><dt>Note</dt><dd>Expects iterators to a container containing <a class="el" href="classTelemetry.html" title="Telemetry record class, allows to store different data using a common interface.">Telemetry</a> class instances. See <a href="https://thingsboard.io/docs/user-guide/telemetry/">https://thingsboard.io/docs/user-guide/telemetry/</a> for more information </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that allows for forward incrementable access to data of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
    <tr><td class="paramname">MaxKeyValuePairAmount</td><td>Maximum amount of key-value pairs, which will ever be sent with this method. Should simply be the biggest distance between first and last iterator this method is ever called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element in the data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the data container (last element + 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pairs into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="aeadd9aa2ccca2e61b5465a239eec367c" name="aeadd9aa2ccca2e61b5465a239eec367c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadd9aa2ccca2e61b5465a239eec367c">&#9670;&#160;</a></span>Send_Telemetry_Data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Telemetry_Data </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the given key-value pair as telemetry data. See <a href="https://thingsboard.io/docs/user-guide/telemetry/">https://thingsboard.io/docs/user-guide/telemetry/</a> for more information. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the passed value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Non owning pointer to the key of the key-value pair. Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the key-value pair </td></tr>
    <tr><td class="paramname">value</td><td>Value of the key-value pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pair into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="af6130abe5e3ad329ae0f90b943bb440e" name="af6130abe5e3ad329ae0f90b943bb440e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6130abe5e3ad329ae0f90b943bb440e">&#9670;&#160;</a></span>Send_Telemetry_Json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Telemetry_Json </td>
          <td>(</td>
          <td class="paramtype">JsonDocument const &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send key-value pairs as telemetry data. See <a href="https://thingsboard.io/docs/user-guide/telemetry/">https://thingsboard.io/docs/user-guide/telemetry/</a> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>JsonDocument containing our json key-value pairs, is checked before usage for any possible occuring internal errors. See <a href="https://arduinojson.org/v6/api/jsondocument/">https://arduinojson.org/v6/api/jsondocument/</a> for more information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pairs into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="a0796d1f7df1f1d7a4a5036098d64894c" name="a0796d1f7df1f1d7a4a5036098d64894c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0796d1f7df1f1d7a4a5036098d64894c">&#9670;&#160;</a></span>Send_Telemetry_String()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Send_Telemetry_String </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send string containing json as telemetry data. See <a href="https://thingsboard.io/docs/user-guide/telemetry/">https://thingsboard.io/docs/user-guide/telemetry/</a> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>Non owning pointer to the string containing our json key-value pairs Does not need to kept alive as the function copies the data into the outgoing MQTT buffer to publish the key-value pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether copying the key-value pairs into the outgoing MQTT buffer, was successful or not </dd></dl>

</div>
</div>
<a id="a454d462aae65f6948dc02235ad4bc824" name="a454d462aae65f6948dc02235ad4bc824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454d462aae65f6948dc02235ad4bc824">&#9670;&#160;</a></span>Set_Buffer_Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Set_Buffer_Size </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>receive_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>send_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of the buffer for sent and received MQTT messages.  </p>
<dl class="section note"><dt>Note</dt><dd>The value can not be bigger than uint16_t because the maximum message size received or sent by MQTT can never be bigger than 64K, because it relies on TCP and the TCP size limit also uses a uint16_t internally for the size parameter </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receive_buffer_size</td><td>Maximum amount of data that can be received via MQTT at once, expected behaviour is that, if bigger packets are received they are discarded and a warning is printed to the console. Should be big enough to hold the biggest response that is expected to be ever received by the device at once </td></tr>
    <tr><td class="paramname">send_buffer_size</td><td>Maximum amount of data that can be sent via MQTT at once, expected behaviour is that, if we attempt to send data that is bigger, it will simply not be sent and a message is printed to the console instead. Should be big enough to hold the biggest request that is expected to be ever sent by the device at once. Alternatively when using Arduino it is possible to enable support for THINGSBOARD_ENABLE_STREAM_UTILS by importing the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) in the project. This feature allows to improve the underlying data streams by directly writing the data into the MQTT Client instead of into an output buffer, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint, which only exists on Arduino This then allows to send arbitrary size payloads if that is done the internal buffer of the MQTT Client implementation can theoretically set the value as big as the buffering_size passed to the constructor + enough memory to hold the topic and MQTT Header ~= 20 bytes. This will mean though that all messages are sent over the StreamUtils library as long as they are bigger than the internal send buffer size, which needs more time than sending a message directly but has the advantage of requiring less memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether allocating the needed memory for the given buffer sizes was successful or not   </dd></dl>

</div>
</div>
<a id="a108d1a5d19663099be779c4be769bdcb" name="a108d1a5d19663099be779c4be769bdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d1a5d19663099be779c4be769bdcb">&#9670;&#160;</a></span>Set_Maximum_Stack_Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Set_Maximum_Stack_Size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>max_stack_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead. </p>
<dl class="section note"><dt>Note</dt><dd>Is used when sending a lot of data at once over MQTT, because to actually send the JsonDocument data it first has to be serialized into a json string payload. To achieve this the data contained in the JsonDocument is copied for the scope of the <a class="el" href="classThingsBoardSized.html#a1a0c1cfbce0cbcfca56ed912e954cfa9">Send_Json</a> method and is then copied into the outgoing MQTT buffer. This variable therefore decides the threshold where the JsonDocument is copied into the heap instead of a object on the stack. This is created to ensure no StackOverflow occurs because most supported boards run the actual sending code in a seperate FreeRTOS Task with limited stack space where even a stack allocation of 4 KiB might already cause a crash To circumvent this copy the alternative mentioned in the send_buffer_size argument of the constructor can also be used because it skips the internal copy alltogether, because the JsonDocument is instead directly copied into the outgoing MQTT buffer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_stack_size</td><td>Maximum amount of bytes we want to allocate on the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac163154d027781fd48b7905ec4a4f4bb" name="ac163154d027781fd48b7905ec4a4f4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac163154d027781fd48b7905ec4a4f4bb">&#9670;&#160;</a></span>Subscribe_API_Implementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Subscribe_API_Implementation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIAPI__Implementation.html">IAPI_Implementation</a> &amp;&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribes the given API implementation. </p>
<dl class="section note"><dt>Note</dt><dd>Ensure the actual API implementation is kept alive as long as the instance of this class. Because the value is not copied, but a non owning pointer to the value is inserted into the local container member variable instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>Additional API that should be connected to ThingsBoard and therefore be able to send and receive data over MQTT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab921a6b407322a6136cb700f1e28c5e3" name="ab921a6b407322a6136cb700f1e28c5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab921a6b407322a6136cb700f1e28c5e3">&#9670;&#160;</a></span>Subscribe_API_Implementations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Subscribe_API_Implementations </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribes the given API implementation. </p>
<dl class="section note"><dt>Note</dt><dd>Ensure the actual API implementations that should be connected to ThingsBoard and therefore be able to send and receive data over MQTT. Ensure the actual API implementations are kept alive as long as the instance of this class. Because the values are not copied, but a non owning pointers to the values are inserted into the local container member variable instead </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that allows for forward incrementable access to data of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element in the data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the data container (last element + 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e455a7e09a73e27b7b95d3d6e622ae" name="a27e455a7e09a73e27b7b95d3d6e622ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e455a7e09a73e27b7b95d3d6e622ae">&#9670;&#160;</a></span>Subscribe_Connection_State_Changed_Callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsize__t.html">size_t</a> MaxResponse = DEFAULT_RESPONSE_AMOUNT, <a class="el" href="classsize__t.html">size_t</a> MaxEndpointsAmount = DEFAULT_ENDPOINT_AMOUNT, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classThingsBoardSized.html">ThingsBoardSized</a>&lt; MaxResponse, MaxEndpointsAmount, Logger &gt;::Subscribe_Connection_State_Changed_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="MQTT__Connection__State_8h.html#a197b96aaf7eb47eade1fba7f36b8d0f6">MQTT_Connection_State</a>, <a class="el" href="MQTT__Connection__Error_8h.html#a2cdc888b0022ba1c7b3a77773ef4fe8b">MQTT_Connection_Error</a> &gt;::function&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, whenever the underlying state of our connection with the MQTT broker changes.  </p>
<dl class="section note"><dt>Note</dt><dd>Is called when we for example attempt to connect to the MQTT broker, or once the underlying client has connected or failed to connect. Passes the current connection state, also accessible with get_connection_state and the last error that occured while trying to connect, also accessible with get_last_connection_error as additional information </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on state changes to our MQTT connection <br  />
  </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="ThingsBoard_8h_source.html">ThingsBoard.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
